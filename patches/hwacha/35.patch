From b8803fb8e1e66ed69f5ec5be4b7b2da72619a876 Mon Sep 17 00:00:00 2001
From: Jiuyang Liu <liu@jiuyang.me>
Date: Sun, 4 Apr 2021 05:17:47 +0000
Subject: [PATCH 1/3] fix for deprecation.

---
 src/main/scala/dcc-mem.scala  |  2 +-
 src/main/scala/vmu-addr.scala |  6 +++---
 src/main/scala/vmu.scala      | 18 +++++++++---------
 3 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/src/main/scala/dcc-mem.scala b/src/main/scala/dcc-mem.scala
index 5746920..b857c6d 100644
--- a/src/main/scala/dcc-mem.scala
+++ b/src/main/scala/dcc-mem.scala
@@ -500,7 +500,7 @@ class VLU(implicit p: Parameters) extends VXUModule()(p)
   val wb_pred = pred << pred_shift
   predq.io.deq.ready := !(pcnt_end || pidx_end)
 
-  unless (busy) {
+  when (!busy) {
     assert(wb === Bits(0), "VLU: non-zero quiescent wb")
     assert(bias_tail === SInt(0), "VLU: non-zero quiescent bias_tail")
     assert(pcnt === UInt(0), "VLU: non-zero quiescent pcnt")
diff --git a/src/main/scala/vmu-addr.scala b/src/main/scala/vmu-addr.scala
index ce6eaaa..8433fb5 100644
--- a/src/main/scala/vmu-addr.scala
+++ b/src/main/scala/vmu-addr.scala
@@ -71,7 +71,7 @@ class ABox0(implicit p: Parameters) extends VMUModule()(p) {
   private val mask = io.mask.bits
   val pred = mask.pred
 
-  unless (op.mode.unit) {
+  when (!op.mode.unit) {
     assert(!io.mask.valid || !pred || (mask.nonunit.shift === UInt(0)),
       "ABox0: simultaneous true predicate and non-zero stride shift")
   }
@@ -119,7 +119,7 @@ class ABox0(implicit p: Parameters) extends VMUModule()(p) {
     }
 
     is (s_busy) {
-      unless (stall || io.xcpt.prop.vmu.stall) {
+      when (!(stall || io.xcpt.prop.vmu.stall)) {
         io.mask.ready := fire(io.mask.valid)
         io.vvaq.ready := fire(vvaq_valid, vvaq_en)
         io.vpaq.valid := fire(vpaq_ready, pred, !io.tlb.resp.xcpt)
@@ -128,7 +128,7 @@ class ABox0(implicit p: Parameters) extends VMUModule()(p) {
         io.agu.in.valid := op.mode.indexed || !mask.last
 
         when (fire(null)) {
-          unless (op.mode.indexed || (op.mode.unit && !mask.unit.page)) {
+          when (!(op.mode.indexed || (op.mode.unit && !mask.unit.page))) {
             op.base := io.agu.out.bits.addr
           }
           when (io.tlb.resp.xcpt && pred) {
diff --git a/src/main/scala/vmu.scala b/src/main/scala/vmu.scala
index 82e5175..035ce93 100644
--- a/src/main/scala/vmu.scala
+++ b/src/main/scala/vmu.scala
@@ -133,17 +133,17 @@ class IBox(implicit p: Parameters) extends VMUModule()(p) {
       _agent.io.id := io.id
       _agent.io.cfg <> io.cfg
       io.agu <> _agent.io.agu
-      _agent
-  } else Module(new IBoxSL)
+      _agent.io
+  } else (Module(new IBoxSL)).io
 
-  agent.io.op.bits := op
-  agent.io.op.valid := opq.io.deq.valid
-  opq.io.deq.ready := agent.io.op.ready
-  io.aret := agent.io.aret
+  agent.op.bits := op
+  agent.op.valid := opq.io.deq.valid
+  opq.io.deq.ready := agent.op.ready
+  io.aret := agent.aret
 
   val issue = Seq(io.abox(0), io.pbox(0),
-    agent.io.span(io.abox(1), io.pbox(1)), io.abox(2))
-  issue zip agent.io.issue map {case(s,d) => s <> d}
+    agent.span(io.abox(1), io.pbox(1)), io.abox(2))
+  issue zip agent.issue map {case(s,d) => s <> d}
 }
 
 class IBoxSL(implicit p: Parameters) extends VMUModule()(p) {
@@ -248,7 +248,7 @@ class IBoxML(implicit p: Parameters) extends VMUModule()(p) {
       enq.valid := !aret_pending && (indexed || io.agu.out.valid)
 
       when (enq.fire()) {
-        unless (indexed) {
+        when (!indexed) {
           op.base := io.agu.out.bits.addr
         }
         op.vlen := vlen_next.asUInt()

From 6c501e0e98b2e2e6213198dbf5e52f11fc30cff3 Mon Sep 17 00:00:00 2001
From: Jiuyang Liu <liu@jiuyang.me>
Date: Thu, 7 Oct 2021 15:25:27 +0800
Subject: [PATCH 2/3] remove cloneType

---
 src/main/scala/bank.scala                 | 3 ---
 src/main/scala/dcc-mem.scala              | 1 -
 src/main/scala/frontend.scala             | 2 --
 src/main/scala/lane.scala                 | 2 --
 src/main/scala/scalar-fpu-interface.scala | 2 --
 src/main/scala/scalar-fpu.scala           | 1 -
 src/main/scala/types-vmu.scala            | 8 --------
 src/main/scala/util.scala                 | 1 -
 src/main/scala/vmu-addr.scala             | 1 -
 src/main/scala/vmu-sdata.scala            | 1 -
 src/main/scala/vmu-table.scala            | 2 --
 11 files changed, 24 deletions(-)

diff --git a/src/main/scala/bank.scala b/src/main/scala/bank.scala
index 86f29ed..2802dfb 100644
--- a/src/main/scala/bank.scala
+++ b/src/main/scala/bank.scala
@@ -36,13 +36,10 @@ class BankOpIO(implicit p: Parameters) extends VXUBundle()(p) {
 }
 
 class BPQIO(implicit p: Parameters) extends DecoupledIO(new BPQEntry()(p)) {
-  override def cloneType = new BPQIO().asInstanceOf[this.type]
 }
 class BRQIO(implicit p: Parameters) extends DecoupledIO(new BRQEntry()(p)) {
-  override def cloneType = new BRQIO().asInstanceOf[this.type]
 }
 class BWQIO(implicit p: Parameters) extends DecoupledIO(new BWQEntry()(p)) {
-  override def cloneType = new BWQIO().asInstanceOf[this.type]
 }
 
 class BankRWIO(implicit p: Parameters) extends VXUBundle()(p) {
diff --git a/src/main/scala/dcc-mem.scala b/src/main/scala/dcc-mem.scala
index 5746920..936dfdc 100644
--- a/src/main/scala/dcc-mem.scala
+++ b/src/main/scala/dcc-mem.scala
@@ -699,7 +699,6 @@ trait VLUSelect extends DCCParameters {
 class VLUSelectBundle(implicit p: Parameters) extends VXUBundle()(p) with VLUSelect
 class VLUSelectIO(implicit p: Parameters)
   extends DecoupledIO(new VLUSelectBundle()(p)) {
-  override def cloneType: this.type = (new VLUSelectIO()).asInstanceOf[this.type]
 }
 
 class VLUMapper(implicit p: Parameters) extends VXUModule()(p) {
diff --git a/src/main/scala/frontend.scala b/src/main/scala/frontend.scala
index 8c547ce..02954e6 100644
--- a/src/main/scala/frontend.scala
+++ b/src/main/scala/frontend.scala
@@ -11,7 +11,6 @@ class FrontendResp(icacheParams: ICacheParams)(implicit p: Parameters) extends H
   val data = UInt(width = icacheParams.fetchBytes * 8)
   val pf = Bool()
 
-  override def cloneType = new FrontendResp(icacheParams).asInstanceOf[this.type]
 }
 
 class FrontendReq(implicit p: Parameters) extends freechips.rocketchip.tile.CoreBundle()(p) {
@@ -25,7 +24,6 @@ class FrontendIO(cacheParams: ICacheParams)(implicit p: Parameters) extends Hwac
   val resp = Decoupled(new FrontendResp(cacheParams)).flip
   val invalidate = Bool(OUTPUT)
 
-  override def cloneType = new FrontendIO(cacheParams).asInstanceOf[this.type]
 }
 
 class MiniFrontend(val cacheParams: ICacheParams)(implicit p: Parameters) extends HwachaModule()(p) with freechips.rocketchip.tile.HasL1CacheParameters {
diff --git a/src/main/scala/lane.scala b/src/main/scala/lane.scala
index 2d8de33..322ce5c 100644
--- a/src/main/scala/lane.scala
+++ b/src/main/scala/lane.scala
@@ -127,10 +127,8 @@ class LaneAckIO(implicit p: Parameters) extends VXUBundle()(p) {
 }
 
 class LPQIO(implicit p: Parameters) extends DecoupledIO(new LPQEntry()(p)) {
-  override def cloneType = new LPQIO().asInstanceOf[this.type]
 }
 class LRQIO(implicit p: Parameters) extends DecoupledIO(new LRQEntry()(p)) {
-  override def cloneType = new LRQIO().asInstanceOf[this.type]
 }
 
 trait LanePred extends VXUBundle {
diff --git a/src/main/scala/scalar-fpu-interface.scala b/src/main/scala/scalar-fpu-interface.scala
index 2088719..481fd08 100644
--- a/src/main/scala/scalar-fpu-interface.scala
+++ b/src/main/scala/scalar-fpu-interface.scala
@@ -73,13 +73,11 @@ class HwachaFPInput(implicit p: Parameters) extends freechips.rocketchip.tile.FP
   val bSRegs = log2Up(p(HwachaNScalarRegs))
   val in_fmt = UInt(width = 2)
   val tag = UInt(width = bSRegs)
-  override def cloneType = new HwachaFPInput()(p).asInstanceOf[this.type]
 }
 
 class HwachaFPResult(implicit p: Parameters) extends freechips.rocketchip.tile.FPResult {
   val bSRegs = log2Up(p(HwachaNScalarRegs))
   val tag = UInt(width = bSRegs)
-  override def cloneType = new HwachaFPResult()(p).asInstanceOf[this.type]
 }
 
 class ScalarFPUInterface(implicit p: Parameters) extends HwachaModule()(p) with Packing with freechips.rocketchip.tile.HasFPUParameters {
diff --git a/src/main/scala/scalar-fpu.scala b/src/main/scala/scalar-fpu.scala
index 7a31ab0..c4d54c4 100644
--- a/src/main/scala/scalar-fpu.scala
+++ b/src/main/scala/scalar-fpu.scala
@@ -77,7 +77,6 @@ class ScalarFPU(implicit p: Parameters) extends HwachaModule()(p) with HasFPUPar
   class WBInfo extends Bundle {
     val single = Bool()
     val pipeid = UInt(width = log2Ceil(pipes.size))
-    override def cloneType: this.type = new WBInfo().asInstanceOf[this.type]
   }
 
   val wen = Reg(init=Bits(0, maxLatency-1))
diff --git a/src/main/scala/types-vmu.scala b/src/main/scala/types-vmu.scala
index ea011aa..d0dfd16 100644
--- a/src/main/scala/types-vmu.scala
+++ b/src/main/scala/types-vmu.scala
@@ -96,7 +96,6 @@ class VVAQEntry(implicit p: Parameters) extends VMUBundle()(p) {
   val addr = UInt(width = bVAddrExtended)
 }
 class VVAQIO(implicit p: Parameters) extends DecoupledIO(new VVAQEntry()(p)) {
-  override def cloneType = new VVAQIO().asInstanceOf[this.type]
 }
 
 trait VMUAddr extends VMUBundle {
@@ -104,7 +103,6 @@ trait VMUAddr extends VMUBundle {
 }
 class VPAQEntry(implicit p: Parameters) extends VMUAddr
 class VPAQIO(implicit p: Parameters) extends DecoupledIO(new VPAQEntry()(p)) {
-  override def cloneType = new VPAQIO().asInstanceOf[this.type]
 }
 
 
@@ -114,7 +112,6 @@ trait VMUData extends VMUBundle {
 
 class VSDQEntry(implicit p: Parameters) extends VMUData
 class VSDQIO(implicit p: Parameters) extends DecoupledIO(new VSDQEntry()(p)) {
-  override def cloneType = new VSDQIO().asInstanceOf[this.type]
 }
 
 class VCUEntry(implicit p: Parameters) extends VMUBundle()(p) {
@@ -148,7 +145,6 @@ class VLDQEntry(implicit p: Parameters) extends VMUData {
   val meta = new VMTLoadEntry
 }
 class VLDQIO(implicit p: Parameters) extends DecoupledIO(new VLDQEntry()(p)) {
-  override def cloneType = new VLDQIO().asInstanceOf[this.type]
 }
 
 /**********************************************************************/
@@ -170,7 +166,6 @@ class VMUMaskEntry_0(implicit p: Parameters) extends VMUBundle()(p) {
   }
 }
 class VMUMaskIO_0(implicit p: Parameters) extends DecoupledIO(new VMUMaskEntry_0()(p)) {
-  override def cloneType = new VMUMaskIO_0().asInstanceOf[this.type]
 }
 
 class VMUMaskEntry_1(implicit p: Parameters) extends VMUBundle()(p) {
@@ -182,7 +177,6 @@ class VMUMaskIO_1(implicit p: Parameters) extends DecoupledIO(new VMUMaskEntry_1
     val eoff = UInt(INPUT, tlByteAddrBits - 1)
     val last = Bool(INPUT)
   }
-  override def cloneType = new VMUMaskIO_1().asInstanceOf[this.type]
 }
 
 /**********************************************************************/
@@ -196,7 +190,6 @@ class CInt(n: Int) extends Bundle {
     raw := x
   }
   def decode(dummy: Int = 0): UInt = Cat(raw === UInt(0), raw)
-  override def cloneType = new CInt(n).asInstanceOf[this.type]
 }
 
 trait VMUMetaCount extends VMUBundle {
@@ -229,5 +222,4 @@ class VMUAddrEntry(implicit p: Parameters) extends VMUMemOp {
   val meta = new VMUMetaAddr with VMUMetaIndex
 }
 class VMUAddrIO(implicit p: Parameters) extends DecoupledIO(new VMUAddrEntry()(p)) {
-  override def cloneType = new VMUAddrIO().asInstanceOf[this.type]
 }
diff --git a/src/main/scala/util.scala b/src/main/scala/util.scala
index 320399f..3fe9042 100644
--- a/src/main/scala/util.scala
+++ b/src/main/scala/util.scala
@@ -170,7 +170,6 @@ class CounterUpdateIO(sz: Int) extends Bundle {
   val cnt = UInt(OUTPUT, sz)
   val update = Bool(OUTPUT)
 
-  override def cloneType = new CounterUpdateIO(sz).asInstanceOf[this.type]
 }
 
 class LookAheadCounter(reset_cnt: Int, max_cnt: Int, resetSignal: Bool = null)(implicit p: Parameters) extends HwachaModule(_reset = resetSignal)(p) with LaneParameters {
diff --git a/src/main/scala/vmu-addr.scala b/src/main/scala/vmu-addr.scala
index ce6eaaa..eaf9dd0 100644
--- a/src/main/scala/vmu-addr.scala
+++ b/src/main/scala/vmu-addr.scala
@@ -39,7 +39,6 @@ class VMUPipeEntry(implicit p: Parameters) extends VMUBundle()(p) {
   val meta = new VMUMetaAddr
 }
 class VMUPipeIO(implicit p: Parameters) extends DecoupledIO(new VMUPipeEntry()(p)) {
-  override def cloneType = new VMUPipeIO().asInstanceOf[this.type]
 }
 
 
diff --git a/src/main/scala/vmu-sdata.scala b/src/main/scala/vmu-sdata.scala
index 99b210f..d3cba68 100644
--- a/src/main/scala/vmu-sdata.scala
+++ b/src/main/scala/vmu-sdata.scala
@@ -17,7 +17,6 @@ class VMUStoreMeta(implicit p: Parameters) extends VMUMetaStore with VMUMetaCoun
 class VMUStoreIO(implicit p: Parameters) extends VSDQIO()(p) {
   val meta = new VMUStoreMeta().asInput
 
-  override def cloneType = new VMUStoreIO().asInstanceOf[this.type]
 }
 
 class SBox(implicit p: Parameters) extends VMUModule()(p) {
diff --git a/src/main/scala/vmu-table.scala b/src/main/scala/vmu-table.scala
index a90aa96..6c05deb 100644
--- a/src/main/scala/vmu-table.scala
+++ b/src/main/scala/vmu-table.scala
@@ -7,14 +7,12 @@ class TableWIO[T <: Data](gen: => T, sztag: Int)
   extends DecoupledIO(gen) {
   val tag = UInt(INPUT, sztag)
 
-  override def cloneType = new TableWIO(gen, sztag).asInstanceOf[this.type]
 }
 
 class TableRIO[T <: Data](gen: => T, sztag: Int)
   extends ValidIO(UInt(width = sztag)) {
   val record = gen.asInput
 
-  override def cloneType = new TableRIO(gen, sztag).asInstanceOf[this.type]
 }
 
 class Table[T <: Data](n: Int, gen: => T) extends Module {

From 34aaffd206a3fe07f6bea05588a20862bf95a68b Mon Sep 17 00:00:00 2001
From: abejgonzalez <abe.j.gonza@gmail.com>
Date: Mon, 17 Jan 2022 15:13:35 -0800
Subject: [PATCH 3/3] Convert fire() to fire

---
 src/main/scala/dcc-fu.scala               |  8 ++++----
 src/main/scala/dcc-mem.scala              | 10 +++++-----
 src/main/scala/frontend.scala             |  2 +-
 src/main/scala/scalar-fpu-interface.scala |  4 ++--
 src/main/scala/scalar-unit.scala          | 14 +++++++-------
 src/main/scala/sequencer-master.scala     |  2 +-
 src/main/scala/smu.scala                  |  2 +-
 src/main/scala/vfu-fdiv.scala             |  6 +++---
 src/main/scala/vfu-idiv.scala             |  6 +++---
 src/main/scala/vfu-rfirst.scala           |  2 +-
 src/main/scala/vfu-rpred.scala            |  2 +-
 src/main/scala/vmu-addr.scala             |  6 +++---
 src/main/scala/vmu-memif.scala            |  2 +-
 src/main/scala/vmu-pred.scala             |  8 ++++----
 src/main/scala/vmu-sdata.scala            |  2 +-
 src/main/scala/vmu-table.scala            |  2 +-
 src/main/scala/vmu-tlb.scala              |  2 +-
 src/main/scala/vmu.scala                  |  6 +++---
 src/main/scala/vru.scala                  |  2 +-
 19 files changed, 44 insertions(+), 44 deletions(-)

diff --git a/src/main/scala/dcc-fu.scala b/src/main/scala/dcc-fu.scala
index 2cbcabb..141c642 100644
--- a/src/main/scala/dcc-fu.scala
+++ b/src/main/scala/dcc-fu.scala
@@ -47,7 +47,7 @@ class VDU(implicit p: Parameters) extends VXUModule()(p) {
   val pcntr = Module(new LookAheadCounter(nBanks+2, nBanks+2))
   pcntr.suggestName("pcntrInst")
   pcntr.io.inc.cnt := UInt(1)
-  pcntr.io.inc.update := lpq.io.deq.fire()
+  pcntr.io.inc.update := lpq.io.deq.fire
   pcntr.io.dec <> io.pla
 
   for (i <- 0 until nVDUOperands) {
@@ -194,7 +194,7 @@ class VDUCtrl(implicit p: Parameters) extends VXUModule()(p) with PackLogic {
     is (s_wait) {
       io.rpred.result.valid := op.active.vrpred
       io.rfirst.result.valid := op.active.vrfirst
-      when (io.rpred.result.fire() || io.rfirst.result.fire()) {
+      when (io.rpred.result.fire || io.rfirst.result.fire) {
         state := s_idle
       }
     }
@@ -286,13 +286,13 @@ class VDUCtrl(implicit p: Parameters) extends VXUModule()(p) with PackLogic {
     fdiv.req.bits.in1 := unpack_slice(io.lrqs.q(1).bits.data, i)
   }
 
-  io.rpred.fu.op.valid := opq.io.deq.fire() && opq.io.deq.bits.active.vrpred
+  io.rpred.fu.op.valid := opq.io.deq.fire && opq.io.deq.bits.active.vrpred
   io.rpred.fu.op.bits := opq.io.deq.bits.fn.vrpu()
   io.rpred.fu.req.valid := fire_rpred(io.rpred.fu.req.ready)
   io.rpred.fu.req.bits.active := pred
   io.rpred.fu.req.bits.pred := io.lpq.bits.pred
 
-  io.rfirst.fu.op.valid := opq.io.deq.fire() && opq.io.deq.bits.active.vrfirst
+  io.rfirst.fu.op.valid := opq.io.deq.fire && opq.io.deq.bits.active.vrfirst
   io.rfirst.fu.op.bits := opq.io.deq.bits.fn.vrfu()
   io.rfirst.fu.req.valid := fire_rfirst(io.rfirst.fu.req.ready)
   io.rfirst.fu.req.bits.active := pred
diff --git a/src/main/scala/dcc-mem.scala b/src/main/scala/dcc-mem.scala
index 9ac6f28..bbf51c4 100644
--- a/src/main/scala/dcc-mem.scala
+++ b/src/main/scala/dcc-mem.scala
@@ -136,7 +136,7 @@ class VPU(implicit p: Parameters) extends VXUModule()(p) with BankLogic {
     val en = io.la.mask(i)
     bpq.io.enq <> enq
     placntr.io.inc.cnt := UInt(1)
-    placntr.io.inc.update := bpq.io.deq.fire()
+    placntr.io.inc.update := bpq.io.deq.fire
     placntr.io.dec.cnt := UInt(1)
     placntr.io.dec.reserve := io.la.reserve && en
     (bpq.io.deq, !en || placntr.io.dec.available)
@@ -401,7 +401,7 @@ class VLU(implicit p: Parameters) extends VXUModule()(p)
   io.map <> map.io.use
 
   val busy = map.io.busy
-  val issue = map.io.use.fire()
+  val issue = map.io.use.fire
 
   /* NOTE: To avoid the need for a full shifter and special masking of
    * final predicate entries, vectors always begin at an nStrip-aligned
@@ -476,7 +476,7 @@ class VLU(implicit p: Parameters) extends VXUModule()(p)
   // NOTE: insert extra cycle of latency for empty predicate short vector race that results in vlu retiring before vcu
   // COLIN: could also be solved with anteq being a flow queue but need to test QoR on that path
   predq.io.enq <> Queue(io.pred)
-  val pred_fire = predq.io.deq.fire()
+  val pred_fire = predq.io.deq.fire
 
   private val bpcnt = bVLen - bStrip + log2Ceil(nVLU)
   val pcnt = Reg(init = UInt(0, bpcnt))
@@ -614,7 +614,7 @@ class VLU(implicit p: Parameters) extends VXUModule()(p)
     bwq.io.enq.bits.data := bwqs_data(i)
     bwq.io.enq.bits.pred := bwqs_mask(i)
 
-    val wb_mask = Mux(bwq.io.deq.fire(), bwq.io.deq.bits.pred, Bits(0))
+    val wb_mask = Mux(bwq.io.deq.fire, bwq.io.deq.bits.pred, Bits(0))
     val wb_vidx = bwq.io.deq.bits.vidx
     val wb_eidx = bwq.io.deq.bits.eidx
     val wb_offset = wb_eidx.zext - bias(wb_vidx)
@@ -739,7 +739,7 @@ class VLUMapper(implicit p: Parameters) extends VXUModule()(p) {
     head := head_next
     used := Bool(false)
   }
-  when (io.use.fire()) {
+  when (io.use.fire) {
     tail := tail_next
     used := Bool(true)
   }
diff --git a/src/main/scala/frontend.scala b/src/main/scala/frontend.scala
index 02954e6..5ab059a 100644
--- a/src/main/scala/frontend.scala
+++ b/src/main/scala/frontend.scala
@@ -51,7 +51,7 @@ class MiniFrontend(val cacheParams: ICacheParams)(implicit p: Parameters) extend
   val s2_xcpt_if = Reg(init=Bool(false))
   val s2_line = Module(new Queue(UInt(width = cacheParams.fetchBytes * 8), 1, pipe=true))
 
-  s1_req_valid := io.back.s0_req.fire()
+  s1_req_valid := io.back.s0_req.fire
 
   val icmiss = s2_valid && !s2_line.io.deq.valid
   val s2_replay = icmiss
diff --git a/src/main/scala/scalar-fpu-interface.scala b/src/main/scala/scalar-fpu-interface.scala
index 481fd08..163c33a 100644
--- a/src/main/scala/scalar-fpu-interface.scala
+++ b/src/main/scala/scalar-fpu-interface.scala
@@ -1,4 +1,4 @@
-package hwacha 
+package hwacha
 
 import Chisel._
 import freechips.rocketchip.config._
@@ -170,7 +170,7 @@ class ScalarFPUInterface(implicit p: Parameters) extends HwachaModule()(p) with
   io.hwacha.resp.valid := respq.io.deq.valid
   io.rocc.resp.ready := respq.io.enq.ready
 
-  when (respq.io.deq.fire()) {
+  when (respq.io.deq.fire) {
     pending_fpu := Bool(false)
   }
 
diff --git a/src/main/scala/scalar-unit.scala b/src/main/scala/scalar-unit.scala
index 485e66c..ff1b01c 100644
--- a/src/main/scala/scalar-unit.scala
+++ b/src/main/scala/scalar-unit.scala
@@ -205,7 +205,7 @@ class ScalarUnit(resetSignal: Bool = null)(implicit p: Parameters) extends Hwach
   when (!killd && id_ctrl.decode_stop) {
     vf_active := Bool(false)
   }
-  io.vf_stop := io.imem.resp.fire() && id_ctrl.decode_stop
+  io.vf_stop := io.imem.resp.fire && id_ctrl.decode_stop
 
   val sren = Vec(
     id_ctrl.vs1_val && id_ctrl.vs1_type === REG_SHR,
@@ -265,8 +265,8 @@ class ScalarUnit(resetSignal: Bool = null)(implicit p: Parameters) extends Hwach
   val id_smu_load = id_ctrl.fn_smu().cmd === SM_L
   val id_smu_store = id_ctrl.fn_smu().cmd === SM_S
   val id_set_sboard =
-    io.vxu.fire() && id_first_inst ||
-    io.fpu.req.fire() || io.smu.req.fire() && id_smu_load || muldiv.io.req.fire()
+    io.vxu.fire && id_first_inst ||
+    io.fpu.req.fire || io.smu.req.fire && id_smu_load || muldiv.io.req.fire
   sboard.set(id_set_sboard, id_ctrl.vd)
 
   val enq_vxu = id_val && id_vector_inst
@@ -454,7 +454,7 @@ class ScalarUnit(resetSignal: Bool = null)(implicit p: Parameters) extends Hwach
   io.smu.req.bits.data := id_sreads(1)
   io.smu.req.bits.tag := id_ctrl.vd
   io.smu.req.bits.status := id_status
-  when (io.smu.req.fire()) { pending_smu := Bool(true) }
+  when (io.smu.req.fire) { pending_smu := Bool(true) }
   when (io.smu.confirm) { pending_smu := Bool(false) }
 
   implicit def BitPatToUInt(x: BitPat): UInt = {
@@ -491,7 +491,7 @@ class ScalarUnit(resetSignal: Bool = null)(implicit p: Parameters) extends Hwach
   val ex_stall_rfirst = ex_reg_valid && io.red.first.valid
 
   io.red.pred.ready := Bool(true)
-  ex_br_resolved := io.red.pred.fire()
+  ex_br_resolved := io.red.pred.fire
   ex_br_taken := ex_br_resolved && io.red.pred.bits.cond
   ex_br_not_taken := ex_br_resolved && !io.red.pred.bits.cond
   when (ex_br_resolved) { pending_cbranch := Bool(false) }
@@ -565,9 +565,9 @@ class ScalarUnit(resetSignal: Bool = null)(implicit p: Parameters) extends Hwach
   io.smu.resp.ready := ll_warb.io.in(1).ready
 
   mrt.io.lret.cnt := UInt(1)
-  mrt.io.lret.update := io.smu.resp.fire() && !io.smu.resp.bits.store
+  mrt.io.lret.update := io.smu.resp.fire && !io.smu.resp.bits.store
   mrt.io.sret.cnt := UInt(1)
-  mrt.io.sret.update := io.smu.resp.fire() && io.smu.resp.bits.store
+  mrt.io.sret.update := io.smu.resp.fire && io.smu.resp.bits.store
 
   ll_warb.io.in(2).valid := muldiv.io.resp.valid
   ll_warb.io.in(2).bits.addr := muldiv.io.resp.bits.tag
diff --git a/src/main/scala/sequencer-master.scala b/src/main/scala/sequencer-master.scala
index 49c3bb1..c24ea5d 100644
--- a/src/main/scala/sequencer-master.scala
+++ b/src/main/scala/sequencer-master.scala
@@ -634,7 +634,7 @@ class MasterSequencer(implicit p: Parameters) extends VXUModule()(p) with SeqLog
     def logic = {
       require(!retired) // must issue before retiring for dhazard bookkeeping
 
-      when (io.op.fire()) {
+      when (io.op.fire) {
         when (io.op.bits.active.vint) { vint }
         when (io.op.bits.active.vipred) { vipred }
         when (io.op.bits.active.vimul) { vimul }
diff --git a/src/main/scala/smu.scala b/src/main/scala/smu.scala
index 89e6ece..26b5968 100644
--- a/src/main/scala/smu.scala
+++ b/src/main/scala/smu.scala
@@ -170,7 +170,7 @@ class SMUModule(outer: SMU)(implicit p: Parameters) extends LazyModuleImp(outer)
 
   io.scalar.resp.valid := grant.valid
   grant.ready := io.scalar.resp.ready
-  tr.valid := io.scalar.resp.fire()
+  tr.valid := io.scalar.resp.fire
   tr.bits := grant.bits.source(log2Up(nSMU)-1,0)
 
   val resp_mt = DecodedMemType(tr.record.mt)
diff --git a/src/main/scala/vfu-fdiv.scala b/src/main/scala/vfu-fdiv.scala
index cf284c5..701e3fa 100644
--- a/src/main/scala/vfu-fdiv.scala
+++ b/src/main/scala/vfu-fdiv.scala
@@ -32,8 +32,8 @@ class FDivSlice(implicit p: Parameters) extends VXUModule()(p) with Packing {
   val qcnt = Module(new QCounter(nDecoupledUnitWBQueue, nDecoupledUnitWBQueue))
   qcnt.suggestName("qcntInst")
 
-  qcnt.io.dec := io.req.fire()
-  qcnt.io.inc := io.resp.fire()
+  qcnt.io.dec := io.req.fire
+  qcnt.io.inc := io.resp.fire
 
   // stage0
   val ins = List(io.req.bits.in0, io.req.bits.in1) map { in =>
@@ -139,7 +139,7 @@ class FDivSlice(implicit p: Parameters) extends VXUModule()(p) with Packing {
   rq.io.enq.bits.exc := s1_result_exc | s1_exc | outtagq.io.deq.bits.exc
 
   assert(!s1_result_valid || rq.io.enq.ready, "result queue should always be ready when a result is about to enqueue")
-  assert(!io.req.fire() || rq.io.enq.ready, "result queue should always be ready when a request fires")
+  assert(!io.req.fire || rq.io.enq.ready, "result queue should always be ready when a request fires")
 
   io.resp <> rq.io.deq
 }
diff --git a/src/main/scala/vfu-idiv.scala b/src/main/scala/vfu-idiv.scala
index 5952e03..f8fc2bc 100644
--- a/src/main/scala/vfu-idiv.scala
+++ b/src/main/scala/vfu-idiv.scala
@@ -34,8 +34,8 @@ class IDivSlice(implicit p: Parameters) extends VXUModule()(p) {
   val qcnt = Module(new QCounter(nDecoupledUnitWBQueue, nDecoupledUnitWBQueue))
   qcnt.suggestName("qcntInst")
 
-  qcnt.io.dec := io.req.fire()
-  qcnt.io.inc := io.resp.fire()
+  qcnt.io.dec := io.req.fire
+  qcnt.io.inc := io.resp.fire
 
   val div = Module(new MulDiv(cfg = MulDivParams(mulUnroll = 8, mulEarlyOut = true, divEarlyOut = true), width = p(HwachaRegLen)))
   div.suggestName("divInst")
@@ -62,7 +62,7 @@ class IDivSlice(implicit p: Parameters) extends VXUModule()(p) {
   div.io.resp.ready := rq.io.enq.ready
 
   assert(!div.io.resp.valid || rq.io.enq.ready, "result queue should always be ready when a result is about to enqueue")
-  assert(!io.req.fire() || rq.io.enq.ready, "result queue should always be ready when a request fires")
+  assert(!io.req.fire || rq.io.enq.ready, "result queue should always be ready when a request fires")
 
   io.resp <> rq.io.deq
 }
diff --git a/src/main/scala/vfu-rfirst.scala b/src/main/scala/vfu-rfirst.scala
index 3edec81..83230cf 100644
--- a/src/main/scala/vfu-rfirst.scala
+++ b/src/main/scala/vfu-rfirst.scala
@@ -37,7 +37,7 @@ class RFirstLane(implicit p: Parameters) extends VXUModule()(p) {
   io.req.ready := Bool(true)
   val pred = PriorityEncoderOH((io.req.bits.active & io.req.bits.pred).asBools)
   val found = pred.reduce(_ || _)
-  when (io.req.fire() && !result.found && found) {
+  when (io.req.fire && !result.found && found) {
     result.found := Bool(true)
     result.lsidx := io.req.bits.lsidx
     result.first := Mux1H(pred, io.req.bits.in)
diff --git a/src/main/scala/vfu-rpred.scala b/src/main/scala/vfu-rpred.scala
index c44184e..593e12c 100644
--- a/src/main/scala/vfu-rpred.scala
+++ b/src/main/scala/vfu-rpred.scala
@@ -31,7 +31,7 @@ class RPredLane(implicit p: Parameters) extends VXUModule()(p) {
   }
 
   io.req.ready := Bool(true)
-  when (io.req.fire()) {
+  when (io.req.fire) {
     when (fn.op_is(FR_ALL)) { cond := cond & (io.req.bits.pred | ~io.req.bits.active).orR }
     when (fn.op_is(FR_ANY)) { cond := cond | (io.req.bits.pred & io.req.bits.active).orR }
   }
diff --git a/src/main/scala/vmu-addr.scala b/src/main/scala/vmu-addr.scala
index 16bcc9f..096c1ed 100644
--- a/src/main/scala/vmu-addr.scala
+++ b/src/main/scala/vmu-addr.scala
@@ -144,7 +144,7 @@ class ABox0(implicit p: Parameters) extends VMUModule()(p) {
     }
   }
 
-  when (io.op.fire()) { /* initialization */
+  when (io.op.fire) { /* initialization */
     state := s_busy
     op := io.op.bits
   }
@@ -225,7 +225,7 @@ class ABox1(implicit p: Parameters) extends VMUModule()(p) {
   val ecnt = Mux(valve_off, offset(valve), ecnt_test)
   /* Track number of elements permitted to depart following VCU */
   val valve_add = Mux(io.la.reserve, io.la.cnt, UInt(0))
-  val valve_sub = Mux(io.mask.fire(), ecnt, UInt(0))
+  val valve_sub = Mux(io.mask.fire, ecnt, UInt(0))
   valve := valve + valve_add - valve_sub
 
   val en = !valve_off || xcpt
@@ -309,7 +309,7 @@ class ABox1(implicit p: Parameters) extends VMUModule()(p) {
     }
   }
 
-  when (io.op.fire()) { /* initialization */
+  when (io.op.fire) { /* initialization */
     state := s_busy
     op := io.op.bits
     blkidx := io.op.bits.base(bPgIdx-1, tlByteAddrBits)
diff --git a/src/main/scala/vmu-memif.scala b/src/main/scala/vmu-memif.scala
index 4b719aa..75150f2 100644
--- a/src/main/scala/vmu-memif.scala
+++ b/src/main/scala/vmu-memif.scala
@@ -96,7 +96,7 @@ class MBox(implicit p: Parameters) extends VMUModule()(p) {
   lbox.bits.meta := vmt.io.r.record.load()
   lbox.valid := resp.valid && !resp.bits.store
   resp.ready := resp.bits.store || lbox.ready
-  vmt.io.r.valid := resp.fire()
+  vmt.io.r.valid := resp.fire
   vmt.io.r.bits := resp.bits.tag
 
   /* Store acknowledgement */
diff --git a/src/main/scala/vmu-pred.scala b/src/main/scala/vmu-pred.scala
index 9740ce0..5dad603 100644
--- a/src/main/scala/vmu-pred.scala
+++ b/src/main/scala/vmu-pred.scala
@@ -152,7 +152,7 @@ class PBox0(implicit p: Parameters) extends VMUModule()(p) {
     sample_en := Bool(true)
   }
 
-  when (io.op.fire()) { /* initialization */
+  when (io.op.fire) { /* initialization */
     state := s_busy
     op := io.op.bits
     index := UInt(0)
@@ -186,12 +186,12 @@ class PBox1(implicit p: Parameters) extends VMUModule()(p) {
   val index_next = (index + step)(lglimit-1, 0)
   val index_end = (index_next === UInt(0))
 
-  when (io.sample.fire()) {
+  when (io.sample.fire) {
     index := index_next
   }
 
   val hold = Reg(Bits(width = limit - 1))
-  when (io.ingress.fire()) {
+  when (io.ingress.fire) {
     hold := io.ingress.bits.pred(nStrip-1, nStrip-limit+1)
   }
 
@@ -283,7 +283,7 @@ class PBox1(implicit p: Parameters) extends VMUModule()(p) {
     }
   }
 
-  when (io.op.fire()) { /* initialization */
+  when (io.op.fire) { /* initialization */
     state := s_busy
     op := io.op.bits
     hold := Bits(0)
diff --git a/src/main/scala/vmu-sdata.scala b/src/main/scala/vmu-sdata.scala
index d3cba68..73cff4d 100644
--- a/src/main/scala/vmu-sdata.scala
+++ b/src/main/scala/vmu-sdata.scala
@@ -56,7 +56,7 @@ class SBox(implicit p: Parameters) extends VMUModule()(p) {
   private val bpart = bbyte - 8
 
   val hold = Reg(Bits(width = tlDataBits - 16))
-  when (vsdq.io.deq.fire()) {
+  when (vsdq.io.deq.fire) {
    /* Byte mode: Align relevant data bits to the upper end of the
       hold register */
     hold := Cat(Mux(op.mt.b,
diff --git a/src/main/scala/vmu-table.scala b/src/main/scala/vmu-table.scala
index 6c05deb..a1e3c18 100644
--- a/src/main/scala/vmu-table.scala
+++ b/src/main/scala/vmu-table.scala
@@ -31,7 +31,7 @@ class Table[T <: Data](n: Int, gen: => T) extends Module {
   private val wtag = io.w.tag
   wtag := CTZ(~valid, n)
 
-  val wen = io.w.fire()
+  val wen = io.w.fire
   val ren = io.r.valid
   val valid_mask_r = ren << rtag
   val valid_mask_w = wen << wtag
diff --git a/src/main/scala/vmu-tlb.scala b/src/main/scala/vmu-tlb.scala
index 363578b..64810da 100644
--- a/src/main/scala/vmu-tlb.scala
+++ b/src/main/scala/vmu-tlb.scala
@@ -64,7 +64,7 @@ class TBox(n: Int)(implicit p: Parameters) extends VMUModule()(p) {
     io.irq.vmu.faulted_ld,
     io.irq.vmu.faulted_st)
 
-  val fire = arb.req.fire()
+  val fire = arb.req.fire
   irqs.zip(xcpts).foreach { case (irq, xcpt) =>
     irq := xcpt && fire
   }
diff --git a/src/main/scala/vmu.scala b/src/main/scala/vmu.scala
index 035ce93..99f13ba 100644
--- a/src/main/scala/vmu.scala
+++ b/src/main/scala/vmu.scala
@@ -221,7 +221,7 @@ class IBoxML(implicit p: Parameters) extends VMUModule()(p) {
   io.aret := Bool(false)
   enq.valid := Bool(false)
 
-  when(io.issue(3).fire()) {
+  when(io.issue(3).fire) {
     qcntr := Mux(qcntr === 0.U, 0.U, (qcntr.zext - 1.S).asUInt)
     io.aret := qcntr === 1.U || aret_pending
     aret_pending := Bool(false)
@@ -247,7 +247,7 @@ class IBoxML(implicit p: Parameters) extends VMUModule()(p) {
       io.agu.in.valid := !indexed
       enq.valid := !aret_pending && (indexed || io.agu.out.valid)
 
-      when (enq.fire()) {
+      when (enq.fire) {
         when (!indexed) {
           op.base := io.agu.out.bits.addr
         }
@@ -259,7 +259,7 @@ class IBoxML(implicit p: Parameters) extends VMUModule()(p) {
           io.op.ready := Bool(true)
           // Last queue is abox2 deepest stage
           // +1+1 because we are enqing this cycle and need to wait for the next op to be eaten by abox2
-          qcntr := qcnts(3) + 1.U + Mux(io.issue(3).fire(), 0.U, 1.U)
+          qcntr := qcnts(3) + 1.U + Mux(io.issue(3).fire, 0.U, 1.U)
           // aret after next issue3.fire
           aret_pending := qcntr =/= 0.U
           assert(qcntr <= UInt(1), "IBox: qcntr too large. aret broken")
diff --git a/src/main/scala/vru.scala b/src/main/scala/vru.scala
index a241e26..caad337 100644
--- a/src/main/scala/vru.scala
+++ b/src/main/scala/vru.scala
@@ -121,7 +121,7 @@ class RunaheadManager(resetSignal: Bool = null)(implicit p: Parameters) extends
 
   // only one of these can be true at a time
   val skipped_block = io.vf_fire && io.vf_skip
-  val accepted_block = io.enq.fire()
+  val accepted_block = io.enq.fire
   assert(!(skipped_block && accepted_block), "VRU attempted to simultaneously enqueue and skip VF block")
   val increment_vf_count = skipped_block || accepted_block
 
