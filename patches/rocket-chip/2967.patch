From 2610dbd85267b9738af97948222c0fda2c1ebb12 Mon Sep 17 00:00:00 2001
From: Jiuyang Liu <liu@jiuyang.me>
Date: Sun, 24 Apr 2022 05:02:26 +0800
Subject: [PATCH] remove objectmodule

---
 src/main/scala/amba/ahb/SRAM.scala            |  17 +-
 src/main/scala/amba/apb/SRAM.scala            |  17 +-
 src/main/scala/amba/axi4/SRAM.scala           |  18 +-
 src/main/scala/devices/debug/Debug.scala      |   7 -
 src/main/scala/devices/debug/Periphery.scala  |   3 -
 src/main/scala/devices/tilelink/CLINT.scala   |   7 +-
 src/main/scala/devices/tilelink/Error.scala   |  20 --
 src/main/scala/devices/tilelink/Plic.scala    |   3 +-
 src/main/scala/devices/tilelink/Zero.scala    |  21 --
 src/main/scala/diplomacy/SRAM.scala           |  16 +-
 .../diplomaticobjectmodel/ConstructOM.scala   |  14 -
 .../DiplomaticObjectModelUtils.scala          | 248 ----------------
 .../HasLogicalTreeNode.scala                  |  12 -
 .../logicaltree/LogicalTreeNode.scala         |  73 -----
 .../logicaltree/LogicalTrees.scala            | 268 ------------------
 .../logicaltree/RocketLogicalTreeNode.scala   | 161 -----------
 .../model/CustomISAExtensions.scala           |  19 --
 .../model/ISASpecifications.scala             |  48 ----
 .../model/OMAddressing.scala                  | 230 ---------------
 .../diplomaticobjectmodel/model/OMBase.scala  |  12 -
 .../model/OMBranchPredictor.scala             |   5 -
 .../model/OMBusError.scala                    |  11 -
 .../model/OMBusMemory.scala                   |  14 -
 .../diplomaticobjectmodel/model/OMCLINT.scala |  10 -
 .../model/OMCaches.scala                      |  79 ------
 .../diplomaticobjectmodel/model/OMCore.scala  |  16 --
 .../model/OMCoreComplex.scala                 |  20 --
 .../diplomaticobjectmodel/model/OMDebug.scala |  72 -----
 .../model/OMDevice.scala                      |   9 -
 .../model/OMErrorDevice.scala                 |  10 -
 .../diplomaticobjectmodel/model/OMFPU.scala   |   9 -
 .../diplomaticobjectmodel/model/OMISA.scala   | 115 --------
 .../model/OMInterrupts.scala                  |  11 -
 .../model/OMMemory.scala                      |  13 -
 .../model/OMMulDiv.scala                      |  45 ---
 .../diplomaticobjectmodel/model/OMPLIC.scala  |  34 ---
 .../diplomaticobjectmodel/model/OMPMP.scala   |  27 --
 .../model/OMPerformanceMonitor.scala          |  27 --
 .../diplomaticobjectmodel/model/OMPorts.scala | 228 ---------------
 .../model/OMRTLModule.scala                   |  62 ----
 .../model/OMRegFieldAccessType.scala          |   9 -
 .../model/OMRegFieldRdAction.scala            |   9 -
 .../model/OMRegFieldWrType.scala              |  16 --
 .../model/OMRocketCore.scala                  |  49 ----
 .../diplomaticobjectmodel/model/OMSRAM.scala  |  14 -
 .../model/OMSpecification.scala               |   9 -
 .../model/OMTestHarness.scala                 |   9 -
 .../diplomaticobjectmodel/model/OMUTLB.scala  |   9 -
 .../model/OMZeroDevice.scala                  |  10 -
 src/main/scala/rocket/DCache.scala            |   6 +-
 src/main/scala/rocket/Frontend.scala          |   3 -
 src/main/scala/rocket/HellaCache.scala        |   3 -
 src/main/scala/rocket/ICache.scala            |   4 +-
 src/main/scala/rocket/NBDcache.scala          |   6 +-
 src/main/scala/rocket/PTW.scala               |   8 +-
 src/main/scala/subsystem/Attachable.scala     |   6 +-
 src/main/scala/subsystem/BaseSubsystem.scala  |  13 -
 src/main/scala/subsystem/HasTiles.scala       |   2 -
 src/main/scala/tile/BaseTile.scala            |   6 -
 src/main/scala/tile/BusErrorUnit.scala        |   6 +-
 src/main/scala/tile/RocketTile.scala          |  14 +-
 src/main/scala/tilelink/RegisterRouter.scala  |   8 +-
 src/main/scala/tilelink/SRAM.scala            |  20 +-
 src/main/scala/util/DescribedSRAM.scala       |  15 +-
 64 files changed, 22 insertions(+), 2263 deletions(-)
 delete mode 100644 src/main/scala/diplomaticobjectmodel/ConstructOM.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/DiplomaticObjectModelUtils.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/HasLogicalTreeNode.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTreeNode.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTrees.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/logicaltree/RocketLogicalTreeNode.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/CustomISAExtensions.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/ISASpecifications.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMAddressing.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMBase.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMBranchPredictor.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMBusError.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMBusMemory.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMCLINT.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMCaches.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMCore.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMCoreComplex.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMDebug.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMDevice.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMErrorDevice.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMFPU.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMISA.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMInterrupts.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMMemory.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMMulDiv.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMPLIC.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMPMP.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMPerformanceMonitor.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMPorts.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMRTLModule.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMRegFieldAccessType.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMRegFieldRdAction.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMRegFieldWrType.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMRocketCore.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMSRAM.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMSpecification.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMTestHarness.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMUTLB.scala
 delete mode 100644 src/main/scala/diplomaticobjectmodel/model/OMZeroDevice.scala

diff --git a/src/main/scala/amba/ahb/SRAM.scala b/src/main/scala/amba/ahb/SRAM.scala
index 9e15a4cc2c3..47d330c674c 100644
--- a/src/main/scala/amba/ahb/SRAM.scala
+++ b/src/main/scala/amba/ahb/SRAM.scala
@@ -5,15 +5,12 @@ package freechips.rocketchip.amba.ahb
 import Chisel._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusMemoryLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.model.AHB_Lite
 import freechips.rocketchip.util._
 import freechips.rocketchip.tilelink.LFSRNoiseMaker
 
 class AHBRAM(
     address: AddressSet,
     cacheable: Boolean = true,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     executable: Boolean = true,
     beatBytes: Int = 4,
     fuzzHreadyout: Boolean = false,
@@ -37,25 +34,13 @@ class AHBRAM(
   lazy val module = new LazyModuleImp(this) with HasJustOneSeqMem {
     val (in, _) = node.in(0)
     val laneDataBits = 8
-    val (mem, omSRAM, omMem) = makeSinglePortedByteWriteSeqMem(
+    val mem = makeSinglePortedByteWriteSeqMem(
       size = BigInt(1) << mask.filter(b=>b).size,
       lanes = beatBytes,
       bits = laneDataBits)
     val eccCode = None
     val address = outer.address
 
-    parentLogicalTreeNode.map {
-      case parentLTN =>
-        def sramLogicalTreeNode = new BusMemoryLogicalTreeNode(
-          device = device,
-          omSRAMs = Seq(omSRAM),
-          busProtocol = new AHB_Lite(None),
-          dataECC = None,
-          hasAtomics = None,
-          busProtocolSpecification = None)
-        LogicalModuleTree.add(parentLTN, sramLogicalTreeNode)
-    }
-
     // The mask and address during the address phase
     val a_access    = in.htrans === AHBParameters.TRANS_NONSEQ || in.htrans === AHBParameters.TRANS_SEQ
     val a_request   = in.hready && in.hsel && a_access
diff --git a/src/main/scala/amba/apb/SRAM.scala b/src/main/scala/amba/apb/SRAM.scala
index 1ae9b18bf7f..b770c748f49 100644
--- a/src/main/scala/amba/apb/SRAM.scala
+++ b/src/main/scala/amba/apb/SRAM.scala
@@ -5,15 +5,12 @@ package freechips.rocketchip.amba.apb
 import Chisel._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusMemoryLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.model.APB
 import freechips.rocketchip.util._
 import freechips.rocketchip.tilelink.LFSRNoiseMaker
 
 class APBRAM(
     address: AddressSet,
     cacheable: Boolean = true,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     executable: Boolean = true,
     beatBytes: Int = 4,
     devName: Option[String] = None,
@@ -37,25 +34,13 @@ class APBRAM(
   lazy val module = new LazyModuleImp(this) with HasJustOneSeqMem {
     val (in, _) = node.in(0)
     val laneDataBits = 8
-    val (mem, omSRAM, omMem) = makeSinglePortedByteWriteSeqMem(
+    val mem = makeSinglePortedByteWriteSeqMem(
       size = BigInt(1) << mask.filter(b=>b).size,
       lanes = beatBytes,
       bits = laneDataBits)
     val eccCode = None
     val address = outer.address
 
-    parentLogicalTreeNode.map {
-      case parentLTN =>
-        def sramLogicalTreeNode = new BusMemoryLogicalTreeNode(
-          device = device,
-          omSRAMs = Seq(omSRAM),
-          busProtocol = new APB(None),
-          dataECC = None,
-          hasAtomics = None,
-          busProtocolSpecification = None)
-        LogicalModuleTree.add(parentLTN, sramLogicalTreeNode)
-    }
-
     val paddr = Cat((mask zip (in.paddr >> log2Ceil(beatBytes)).asBools).filter(_._1).map(_._2).reverse)
     val legal = address.contains(in.paddr)
 
diff --git a/src/main/scala/amba/axi4/SRAM.scala b/src/main/scala/amba/axi4/SRAM.scala
index 9ffe3ce6a87..f54f5cb281f 100644
--- a/src/main/scala/amba/axi4/SRAM.scala
+++ b/src/main/scala/amba/axi4/SRAM.scala
@@ -5,8 +5,6 @@ package freechips.rocketchip.amba.axi4
 import Chisel._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusMemoryLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.model.AXI4_Lite
 import freechips.rocketchip.util._
 import freechips.rocketchip.amba._
 
@@ -15,7 +13,6 @@ import freechips.rocketchip.amba._
 class AXI4RAM(
     address: AddressSet,
     cacheable: Boolean = true,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     executable: Boolean = true,
     beatBytes: Int = 4,
     devName: Option[String] = None,
@@ -41,25 +38,13 @@ class AXI4RAM(
   lazy val module = new LazyModuleImp(this) with HasJustOneSeqMem {
     val (in, edgeIn) = node.in(0)
     val laneDataBits = 8
-    val (mem, omSRAM, omMem) = makeSinglePortedByteWriteSeqMem(
+    val mem = makeSinglePortedByteWriteSeqMem(
       size = BigInt(1) << mask.filter(b=>b).size,
       lanes = beatBytes,
       bits = laneDataBits)
     val eccCode = None
     val address = outer.address
 
-    parentLogicalTreeNode.map {
-      case parentLTN =>
-        def sramLogicalTreeNode = new BusMemoryLogicalTreeNode(
-          device = device,
-          omSRAMs = Seq(omSRAM),
-          busProtocol = new AXI4_Lite(None),
-          dataECC = None,
-          hasAtomics = None,
-          busProtocolSpecification = None)
-        LogicalModuleTree.add(parentLTN, sramLogicalTreeNode)
-    }
-
     val corrupt = if (edgeIn.bundle.requestFields.contains(AMBACorrupt)) Some(SeqMem(1 << mask.filter(b=>b).size, UInt(width=2))) else None
 
     val r_addr = Cat((mask zip (in.ar.bits.addr >> log2Ceil(beatBytes)).asBools).filter(_._1).map(_._2).reverse)
@@ -129,7 +114,6 @@ object AXI4RAM
   def apply(
     address: AddressSet,
     cacheable: Boolean = true,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     executable: Boolean = true,
     beatBytes: Int = 4,
     devName: Option[String] = None,
diff --git a/src/main/scala/devices/debug/Debug.scala b/src/main/scala/devices/debug/Debug.scala
index 8ab84fc6390..d2a4846a32e 100755
--- a/src/main/scala/devices/debug/Debug.scala
+++ b/src/main/scala/devices/debug/Debug.scala
@@ -16,7 +16,6 @@ import freechips.rocketchip.interrupts._
 import freechips.rocketchip.util._
 import freechips.rocketchip.devices.debug.systembusaccess._
 import freechips.rocketchip.devices.tilelink.TLBusBypass
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.DebugLogicalTreeNode
 import freechips.rocketchip.amba.apb.{APBToTL, APBFanout}
 import freechips.rocketchip.util.BooleanToAugmentedBoolean
 
@@ -1883,10 +1882,4 @@ class TLDebugModule(beatBytes: Int)(implicit p: Parameters) extends LazyModule {
     io.auth.foreach { x => dmOuter.module.io.dmAuthenticated.get := x.dmAuthenticated }
     io.auth.foreach { x => dmInner.module.io.auth.foreach {y => x <> y}}
   }
-
-  val logicalTreeNode = new DebugLogicalTreeNode(
-    device,
-    () => dmOuter,
-    () => dmInner
-  )
 }
diff --git a/src/main/scala/devices/debug/Periphery.scala b/src/main/scala/devices/debug/Periphery.scala
index 812dffb6f9d..3aca36ad273 100644
--- a/src/main/scala/devices/debug/Periphery.scala
+++ b/src/main/scala/devices/debug/Periphery.scala
@@ -10,7 +10,6 @@ import freechips.rocketchip.config.{Field, Parameters}
 import freechips.rocketchip.subsystem._
 import freechips.rocketchip.amba.apb._
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.LogicalModuleTree
 import freechips.rocketchip.jtag._
 import freechips.rocketchip.util._
 import freechips.rocketchip.prci.{ClockSinkParameters, ClockSinkNode}
@@ -83,8 +82,6 @@ trait HasPeripheryDebug { this: BaseSubsystem =>
   val debugOpt = p(DebugModuleKey).map { params =>
     val debug = LazyModule(new TLDebugModule(tlbus.beatBytes))
 
-    LogicalModuleTree.add(logicalTreeNode, debug.logicalTreeNode)
-
     debug.node := tlbus.coupleTo("debug"){ TLFragmenter(tlbus) := _ }
     debug.dmInner.dmInner.customNode := debugCustomXbarOpt.get.node
 
diff --git a/src/main/scala/devices/tilelink/CLINT.scala b/src/main/scala/devices/tilelink/CLINT.scala
index 3cac1e19ac0..f3150ca9608 100644
--- a/src/main/scala/devices/tilelink/CLINT.scala
+++ b/src/main/scala/devices/tilelink/CLINT.scala
@@ -5,8 +5,6 @@ package freechips.rocketchip.devices.tilelink
 import Chisel._
 import freechips.rocketchip.config.{Field, Parameters}
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree._
-import freechips.rocketchip.diplomaticobjectmodel.model._
 import freechips.rocketchip.interrupts._
 import freechips.rocketchip.regmapper._
 import freechips.rocketchip.subsystem._
@@ -89,7 +87,7 @@ class CLINT(params: CLINTParams, beatBytes: Int)(implicit p: Parameters) extends
      * bffc mtime hi
      */
 
-    val omRegMap : OMRegisterMap = node.regmap(
+    node.regmap(
       0                -> RegFieldGroup ("msip", Some("MSIP Bits"), ipi.zipWithIndex.flatMap{ case (r, i) =>
         RegField(1, r, RegFieldDesc(s"msip_$i", s"MSIP bit for Hart $i", reset=Some(0))) :: RegField(ipiWidth - 1) :: Nil }),
       timecmpOffset(0) -> timecmp.zipWithIndex.flatMap{ case (t, i) => RegFieldGroup(s"mtimecmp_$i", Some(s"MTIMECMP for hart $i"),
@@ -98,8 +96,6 @@ class CLINT(params: CLINTParams, beatBytes: Int)(implicit p: Parameters) extends
         RegField.bytes(time, Some(RegFieldDesc("mtime", "", reset=Some(0), volatile=true))))
     )
   }
-
-  def logicalTreeNode: CLINTLogicalTreeNode = new CLINTLogicalTreeNode(device, module.omRegMap)
 }
 
 /** Trait that will connect a CLINT to a subsystem */
@@ -107,7 +103,6 @@ trait CanHavePeripheryCLINT { this: BaseSubsystem =>
   val clintOpt = p(CLINTKey).map { params =>
     val tlbus = locateTLBusWrapper(p(CLINTAttachKey).slaveWhere)
     val clint = LazyModule(new CLINT(params, cbus.beatBytes))
-    LogicalModuleTree.add(logicalTreeNode, clint.logicalTreeNode)
     clint.node := tlbus.coupleTo("clint") { TLFragmenter(tlbus) := _ }
 
     // Override the implicit clock and reset -- could instead include a clockNode in the clint, and make it a RawModuleImp?
diff --git a/src/main/scala/devices/tilelink/Error.scala b/src/main/scala/devices/tilelink/Error.scala
index 1f9134e6c6a..c191598e6bf 100644
--- a/src/main/scala/devices/tilelink/Error.scala
+++ b/src/main/scala/devices/tilelink/Error.scala
@@ -7,32 +7,12 @@ import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tilelink._
 
-import freechips.rocketchip.diplomaticobjectmodel.{DiplomaticObjectModelAddressing, HasLogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.LogicalTreeNode
-import freechips.rocketchip.diplomaticobjectmodel.model.{OMErrorDevice, OMComponent}
-
 /** Adds a /dev/null slave that generates TL error response messages */
 class TLError(params: DevNullParams, buffer: Boolean = true, beatBytes: Int = 4)(implicit p: Parameters)
     extends DevNullDevice(params,
       minLatency = if (buffer) 1 else 0,
       beatBytes, new SimpleDevice("error-device", Seq("sifive,error0")))
-    with HasLogicalTreeNode
 {
-  lazy val logicalTreeNode: LogicalTreeNode = new LogicalTreeNode(() => Some(device)) {
-    def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil) = {
-      val Description(name, mapping) = device.describe(resourceBindings)
-      val memRegions = DiplomaticObjectModelAddressing.getOMMemoryRegions(name, resourceBindings, None)
-      val interrupts = DiplomaticObjectModelAddressing.describeInterrupts(name, resourceBindings)
-      Seq(OMErrorDevice(
-        memoryRegions = memRegions.map(_.copy(
-          name = "errordevice",
-          description = "Error Device"
-        )),
-        interrupts = interrupts
-      ))
-    }
-  }
-
   lazy val module = new LazyModuleImp(this) {
     import TLMessages._
     import TLPermissions._
diff --git a/src/main/scala/devices/tilelink/Plic.scala b/src/main/scala/devices/tilelink/Plic.scala
index 91daa36270f..a6168950449 100644
--- a/src/main/scala/devices/tilelink/Plic.scala
+++ b/src/main/scala/devices/tilelink/Plic.scala
@@ -15,7 +15,6 @@ import freechips.rocketchip.util._
 import freechips.rocketchip.util.property
 import freechips.rocketchip.prci.{ClockSinkDomain}
 import chisel3.internal.sourceinfo.SourceInfo
-import freechips.rocketchip.diplomaticobjectmodel.model._
 
 import scala.math.min
 
@@ -306,7 +305,7 @@ class TLPLIC(params: PLICParams, beatBytes: Int)(implicit p: Parameters) extends
       )
     }
 
-    val omRegMap : OMRegisterMap = node.regmap((priorityRegFields ++ pendingRegFields ++ enableRegFields ++ hartRegFields):_*)
+    node.regmap((priorityRegFields ++ pendingRegFields ++ enableRegFields ++ hartRegFields):_*)
 
     if (nDevices >= 2) {
       val claimed = claimer(0) && maxDevs(0) > 0
diff --git a/src/main/scala/devices/tilelink/Zero.scala b/src/main/scala/devices/tilelink/Zero.scala
index 299ba97f9d3..9ccfc64a314 100644
--- a/src/main/scala/devices/tilelink/Zero.scala
+++ b/src/main/scala/devices/tilelink/Zero.scala
@@ -7,10 +7,6 @@ import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tilelink.TLMessages
 
-import freechips.rocketchip.diplomaticobjectmodel.{DiplomaticObjectModelAddressing, HasLogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.LogicalTreeNode
-import freechips.rocketchip.diplomaticobjectmodel.model.{OMZeroDevice, OMComponent}
-
 /** This /dev/null device accepts single beat gets/puts, as well as atomics.
   * Response data is always 0. Reequests to write data have no effect.
   */
@@ -27,24 +23,7 @@ class TLZero(address: AddressSet, beatBytes: Int = 4)(implicit p: Parameters)
     minLatency = 1,
     beatBytes = beatBytes,
     device = new SimpleDevice("rom", Seq("ucbbar,cacheable-zero0")))
-    with HasLogicalTreeNode
 {
-
-  lazy val logicalTreeNode: LogicalTreeNode = new LogicalTreeNode(() => Some(device)) {
-    def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil) = {
-      val Description(name, mapping) = device.describe(resourceBindings)
-      val memRegions = DiplomaticObjectModelAddressing.getOMMemoryRegions(name, resourceBindings, None)
-      val interrupts = DiplomaticObjectModelAddressing.describeInterrupts(name, resourceBindings)
-      Seq(OMZeroDevice(
-        memoryRegions = memRegions.map(_.copy(
-          name = "zerodevice",
-          description = "Zero Device"
-        )),
-        interrupts = interrupts
-      ))
-    }
-  }
-
   lazy val module = new LazyModuleImp(this) {
     val (in, edge) = node.in(0)
 
diff --git a/src/main/scala/diplomacy/SRAM.scala b/src/main/scala/diplomacy/SRAM.scala
index b6c265f5dfe..1ab941d6be9 100644
--- a/src/main/scala/diplomacy/SRAM.scala
+++ b/src/main/scala/diplomacy/SRAM.scala
@@ -5,8 +5,6 @@ package freechips.rocketchip.diplomacy
 import Chisel._
 import chisel3.SyncReadMem
 import freechips.rocketchip.config.Parameters
-import freechips.rocketchip.diplomaticobjectmodel.DiplomaticObjectModelAddressing
-import freechips.rocketchip.diplomaticobjectmodel.model._
 import freechips.rocketchip.util.{DescribedSRAM, Code}
 
 abstract class DiplomaticSRAM(
@@ -19,10 +17,6 @@ abstract class DiplomaticSRAM(
     .map(new SimpleDevice(_, dtsCompat.getOrElse(Seq("sifive,sram0"))))
     .getOrElse(new MemoryDevice())
 
-  def getOMMemRegions(resourceBindings: ResourceBindings): Seq[OMMemoryRegion] = {
-    DiplomaticObjectModelAddressing.getOMMemoryRegions(devName.getOrElse(""), resourceBindings) // TODO name source???
-  }
-
   val resources = device.reg("mem")
 
   def bigBits(x: BigInt, tail: List[Boolean] = Nil): List[Boolean] =
@@ -34,7 +28,7 @@ abstract class DiplomaticSRAM(
   def makeSinglePortedByteWriteSeqMem(size: BigInt, lanes: Int = beatBytes, bits: Int = 8) = {
     // We require the address range to include an entire beat (for the write mask)
 
-    val (mem, omSRAM) =  DescribedSRAM(
+    val mem  =  DescribedSRAM(
       name = devName.getOrElse("mem"),
       desc = devName.getOrElse("mem"),
       size = size,
@@ -42,13 +36,7 @@ abstract class DiplomaticSRAM(
     )
     devName.foreach(n => mem.suggestName(n.split("-").last))
 
-    val omMem: OMMemory = DiplomaticObjectModelAddressing.makeOMMemory(
-      desc = "mem", //lim._2.name.map(n => n).getOrElse(lim._1.name),
-      depth = size,
-      data = Vec(lanes, UInt(width = bits))
-    )
-
-    (mem, omSRAM, Seq(omMem))
+    mem
   }
 }
 
diff --git a/src/main/scala/diplomaticobjectmodel/ConstructOM.scala b/src/main/scala/diplomaticobjectmodel/ConstructOM.scala
deleted file mode 100644
index 96836504847..00000000000
--- a/src/main/scala/diplomaticobjectmodel/ConstructOM.scala
+++ /dev/null
@@ -1,14 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel
-
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree._
-import freechips.rocketchip.diplomaticobjectmodel.model.OMComponent
-import freechips.rocketchip.util.ElaborationArtefacts
-
-case object ConstructOM {
-  def constructOM(): Unit = {
-    val om: Seq[OMComponent] = LogicalModuleTree.bind()
-    ElaborationArtefacts.add("objectModel.json", DiplomaticObjectModelUtils.toJson(om))
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/DiplomaticObjectModelUtils.scala b/src/main/scala/diplomaticobjectmodel/DiplomaticObjectModelUtils.scala
deleted file mode 100644
index d58cf7d4e46..00000000000
--- a/src/main/scala/diplomaticobjectmodel/DiplomaticObjectModelUtils.scala
+++ /dev/null
@@ -1,248 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel
-
-import java.io.{File, FileWriter}
-
-import Chisel.{Data, Vec, log2Ceil}
-import freechips.rocketchip.diplomacy.{ AddressSet, Binding, Device, DiplomacyUtils, ResourceAddress, ResourceBindings, ResourceInt, ResourceMapping, ResourcePermissions, ResourceValue, SimpleDevice}
-import freechips.rocketchip.diplomaticobjectmodel.model._
-import org.json4s.jackson.JsonMethods.pretty
-import org.json4s.jackson.Serialization
-import org.json4s.{CustomSerializer, Extraction, NoTypeHints}
-
-
-object DiplomaticObjectModelUtils {
-
-  def toJson(json: Any): String = {
-    implicit val formats = Serialization.formats(NoTypeHints) + new OMEnumSerializer
-    pretty(Extraction.decompose(json))
-  }
-
-  def addTypes(json: Any): String = {
-    toJson(json)
-  }
-
-  def writeJsonFile(filename: String, json: Map[String, Any]): Unit = {
-    val writer = new FileWriter(new File(filename))
-    writer.write(toJson(json))
-    writer.close()
-  }
-
-  /**
-   * Get the demangled name for the class.
-   *
-   * In Scala companion objects have a trailing $, so this will strip the
-   * trailing $.
-   */
-  def getDemangledName(claz: Class[_]): String =
-    """\$.*$""".r.replaceFirstIn(claz.getSimpleName, "")
-
-  /**
-    * Given a sequence of strings, remove duplicates by keeping only
-    *   the last occurrence in the sequence.
-    */
-  def keepLast(names: Seq[String]): Seq[String] = {
-    var keepers = List[String]()
-    var seen = Set[String]()
-
-    // Coded as an imperative loop, could easily be functional.
-    for (name <- names.reverse)
-      if (!seen(name)) {
-        keepers = name +: keepers
-        seen = seen + name
-      }
-
-    keepers.toSeq
-  }
-
-  /**
-   * Get a list of super classes and traits for a class
-   */
-  def getSuperClasses(klass: Class[_]): Seq[Class[_]] = {
-
-    if (klass == null)
-      Seq()
-
-    else {
-      val superKlass = klass.getSuperclass
-      val interfaces = klass.getInterfaces
-      val classes    = klass.getClasses
-
-      val parents = if (superKlass == null)  interfaces
-      else          interfaces :+ superKlass
-
-      val ancestors = for {parent <- parents; ancestor <- getSuperClasses(parent)}
-        yield ancestor
-
-      (klass +: parents) ++ ancestors
-    }
-  }
-
-  def getAllClassNames(klass: Class[_]): Seq[String] =
-    keepLast(getSuperClasses(klass).map(getDemangledName _))
-}
-
-class OMEnumSerializer extends CustomSerializer[OMEnum](format => {
-  import org.json4s.JsonDSL._
-  (
-    Map.empty,
-    {
-      // Note: This is only meant to work for our OMEnum types, where we don't
-      // need to recursively serialize child properties because our OMEnum types
-      // do not have members. We currently don't have a way of recursively
-      // serializing objects without basically reimplementing the default
-      // serializers for case classes.
-      case inst: OMEnum => ("_types" -> DiplomaticObjectModelUtils.getAllClassNames(inst.getClass))
-    }
-  )
-})
-
-object DiplomaticObjectModelAddressing {
-  def getOMComponentHelper(resourceBindings: ResourceBindings, fn: (ResourceBindings) => Seq[OMComponent]): Seq[OMComponent] = {
-    fn(resourceBindings)
-  }
-
-  private def omPerms(p: ResourcePermissions): OMPermissions = {
-    OMPermissions(
-      readable = p.r,
-      writeable = p.w,
-      executable = p.x,
-      cacheable = p.c,
-      atomics = p.a
-    )
-  }
-
-  private def omAddressSets(ranges: Seq[AddressSet], name: String): Seq[OMAddressSet] = {
-    ranges.map {
-      case AddressSet(base, mask) =>
-        require(mask != 0, s"omAddressSets: $name has invalid mask of 0")
-        OMAddressSet(base = base, mask = mask)
-    }
-  }
-
-  private def omMemoryRegion(name: String, description: String, value: ResourceValue,
-    omRegMap: Option[OMRegisterMap],
-    omAddressBlocks: Seq[OMAddressBlock] = Nil): OMMemoryRegion = {
-    val (omRanges, permissions) = value match {
-      case rm: ResourceMapping =>
-        (omAddressSets(rm.address, name),rm.permissions)
-      case ra: ResourceAddress => (omAddressSets(ra.address, name), ra.permissions)
-      case _ => throw new IllegalArgumentException()
-    }
-
-    OMMemoryRegion(
-      name = name,
-      description = description,
-      addressSets = omRanges,
-      permissions = omPerms(permissions),
-      registerMap = omRegMap,
-      addressBlocks = (omAddressBlocks ++ omRegMap.map{_.addressBlocks}.getOrElse(Nil)).distinct
-    )
-  }
-
-  def getOMInterrupts(resourceBindings: ResourceBindings): Seq[OMInterrupt]= {
-    Nil
-  }
-
-  def getOMMemoryRegions(name: String, resourceBindings: ResourceBindings, omRegMap: Option[OMRegisterMap] = None,
-    omAddressBlocks: Seq[OMAddressBlock] = Nil): Seq[OMMemoryRegion] = {
-    val result =  resourceBindings.map.collect {
-      case (x: String, seq: Seq[Binding]) if (DiplomacyUtils.regFilter(x) || DiplomacyUtils.rangeFilter(x)) =>
-        seq.map {
-          case Binding(device: Option[Device], value: ResourceValue) =>
-            omMemoryRegion(name, DiplomacyUtils.regName(x).getOrElse(""), value, omRegMap, omAddressBlocks)
-        }
-    }.flatten.toSeq
-    require(omRegMap.isEmpty || (result.size == 1),
-      s"If Register Map is specified, there must be exactly one Memory Region, not ${result.size}")
-    result
-  }
-
-  def getOMPortMemoryRegions(name: String, resourceBindings: ResourceBindings, omRegMap: Option[OMRegisterMap] = None): Seq[OMMemoryRegion]= {
-    resourceBindings.map.collect {
-      case (x: String, seq: Seq[Binding]) if (DiplomacyUtils.regFilter(x) || DiplomacyUtils.rangeFilter(x)) =>
-        seq.map {
-          case Binding(device: Option[Device], value: ResourceValue) => omMemoryRegion(name, "port memory region", value, omRegMap)
-        }
-    }.flatten.toSeq
-  }
-
-  def makeOMSRAM(
-    desc: String,
-    width: Int,
-    depth: BigInt,
-    granWidth: Int,
-    uid: Int,
-    rtlModule: OMRTLModule = OMRTLModule()
-  ): OMSRAM = {
-    OMSRAM(
-      description = desc,
-      addressWidth = log2Ceil(depth),
-      dataWidth = width,
-      depth = depth,
-      writeMaskGranularity = granWidth,
-      uid = uid,
-      rtlModule = rtlModule
-    )
-  }
-
-  def makeOMMemory[T <: Data](
-      desc: String,
-      depth: BigInt,
-      data: T
-    ): OMMemory = {
-
-      val granWidth = data match {
-        case v: Vec[_] => v.head.getWidth
-        case d => d.getWidth
-      }
-
-      OMMemory(
-        description = desc,
-        addressWidth = log2Ceil(depth),
-        dataWidth = data.getWidth,
-        depth = depth,
-        writeMaskGranularity = granWidth
-      )
-    }
-
-  private def getInterruptNumber(r: ResourceValue): BigInt = {
-    r match {
-      case ResourceInt(value: BigInt) => value
-      case _ => throw new IllegalArgumentException
-    }
-  }
-
-  private def getDeviceName(device: Device, resources: ResourceBindings): String = {
-    device match {
-      case sd:SimpleDevice => sd.asInstanceOf[SimpleDevice].deviceNamePlusAddress
-      case _ => throw new IllegalArgumentException(s"Error: getDeviceName: " + device.getClass.toString() + "\n")
-    }
-  }
-
-  def describeInterrupts(name: String, resources: ResourceBindings): Seq[OMInterrupt] = {
-    val int = resources("int")
-    for {
-      b <- int
-      grandParentOpt = b.device.get.parent
-      gp <- grandParentOpt
-    } yield OMInterrupt(
-      receiver = getDeviceName(gp, resources),
-      numberAtReceiver = getInterruptNumber(b.value),
-      name = name
-    )
-  }
-
-  def describeGlobalInterrupts(name: String, resources: ResourceBindings): Seq[OMInterrupt] = {
-    val bindings = resources("int")
-    for {
-      binding <- bindings
-      device = binding.device.get
-    } yield OMInterrupt(
-      receiver = device.describe(resources).name,
-      numberAtReceiver = getInterruptNumber(binding.value),
-      name = name
-    )
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/HasLogicalTreeNode.scala b/src/main/scala/diplomaticobjectmodel/HasLogicalTreeNode.scala
deleted file mode 100644
index 298823d40cf..00000000000
--- a/src/main/scala/diplomaticobjectmodel/HasLogicalTreeNode.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel
-
-
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree._
-
-trait HasLogicalTreeNode {
-  def logicalTreeNode: LogicalTreeNode
-  def addLogicalTreeNode(childLogicalTreeNode: LogicalTreeNode): Unit = LogicalModuleTree.add(logicalTreeNode, childLogicalTreeNode)
-}
-
diff --git a/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTreeNode.scala b/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTreeNode.scala
deleted file mode 100644
index 2530e7a2264..00000000000
--- a/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTreeNode.scala
+++ /dev/null
@@ -1,73 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.logicaltree
-
-import freechips.rocketchip.diplomacy.{BindingScope, Device, ResourceBindings, ResourceBindingsMap, SimpleDevice}
-import freechips.rocketchip.diplomaticobjectmodel.model.OMComponent
-
-import scala.collection.mutable
-import scala.collection.mutable.ArrayBuffer
-
-abstract class LogicalTreeNode(protected val deviceOpt: () => Option[Device]) {
-  def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil): Seq[OMComponent]
-
-  def getDevice = deviceOpt
-}
-
-class GenericLogicalTreeNode extends LogicalTreeNode(() => None) {
-  override def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil): Seq[OMComponent] =
-    children
-}
-
-
-object LogicalModuleTree {
-  private val tree: mutable.Map[LogicalTreeNode, Seq[LogicalTreeNode]] = mutable.Map[LogicalTreeNode, Seq[LogicalTreeNode]]()
-
-  def add(parent: LogicalTreeNode, child: => LogicalTreeNode): Unit = {
-    require(parent != null, "Cannot add null parent to the LogicalModuleTree")
-    require(child != null, "Cannot add null child to the LogicalModuleTree")
-    val treeOpt = tree.get(parent)
-    val treeNode = treeOpt.map{
-      children => child +: children
-    }.getOrElse(Seq(child))
-    tree.put(parent, treeNode)
-  }
-
-  def rootLogicalTreeNode: LogicalTreeNode = {
-    val roots = tree.collect { case (k, _) if !tree.exists(_._2.contains(k)) => k }
-    require(roots.size == 1, s"Logical Tree contains more than one root:\n$roots")
-    roots.head
-  }
-
-  def getResourceBindings(device: Device, maps: ArrayBuffer[ResourceBindingsMap]): ResourceBindings = {
-    val rbm = maps.find {
-      rbm => rbm.map.contains(device)
-    }.getOrElse {
-      throw new IllegalArgumentException(s"""ResourceBindingsMap not found in BindingScope.resourceBindingsMaps""")
-    }
-
-    rbm.map.get(device).getOrElse(
-      throw new IllegalArgumentException(s"""Device not found = ${device.asInstanceOf[SimpleDevice].devname} in BindingScope.resourceBindingsMaps""")
-    )
-  }
-
-  def resourceBindings(deviceOpt: () => Option[Device], maps: ArrayBuffer[ResourceBindingsMap]): ResourceBindings = deviceOpt() match {
-    case Some(device) => getResourceBindings(device, maps)
-    case None => ResourceBindings()
-  }
-
-  def cache() = BindingScope.bindingScopes.map(_.getResourceBindingsMap)
-
-  def treeIsEmpty() = tree.size == 0
-
-  def bind(): Seq[OMComponent] = {
-    val resourceBindingsMaps= cache()
-
-    def getOMComponentTree(node: LogicalTreeNode): Seq[OMComponent] = {
-      val rbs = resourceBindings(node.getDevice, resourceBindingsMaps)
-      node.getOMComponents(rbs, tree.get(node).getOrElse(Nil).flatMap(getOMComponentTree))
-    }
-
-    getOMComponentTree(rootLogicalTreeNode)
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTrees.scala b/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTrees.scala
deleted file mode 100644
index e3533819d5c..00000000000
--- a/src/main/scala/diplomaticobjectmodel/logicaltree/LogicalTrees.scala
+++ /dev/null
@@ -1,268 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.logicaltree
-
-import freechips.rocketchip.config._
-import freechips.rocketchip.devices.debug._
-import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.DiplomaticObjectModelAddressing
-import freechips.rocketchip.diplomaticobjectmodel.model._
-import freechips.rocketchip.tile.MaxHartIdBits
-
-class CLINTLogicalTreeNode(device: SimpleDevice, f: => OMRegisterMap) extends LogicalTreeNode(() => Some(device)) {
-
-  def getOMCLINT(resourceBindings: ResourceBindings): Seq[OMComponent] = {
-    val memRegions : Seq[OMMemoryRegion]= DiplomaticObjectModelAddressing.getOMMemoryRegions("CLINT", resourceBindings, Some(f))
-
-    Seq[OMComponent](
-      OMCLINT(
-        memoryRegions = memRegions,
-        interrupts = Nil,
-        specifications = List(
-          OMSpecification(
-            name = "The RISC-V Instruction Set Manual, Volume II: Privileged Architecture",
-            version = "1.10"
-          )
-        )
-      )
-    )
-  }
-
-  def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    DiplomaticObjectModelAddressing.getOMComponentHelper(resourceBindings, getOMCLINT)
-  }
-}
-
-class DebugLogicalTreeNode(
-  device: SimpleDevice,
-  dmOuter: () => TLDebugModuleOuterAsync,
-  dmInner: () => TLDebugModuleInnerAsync
-)(implicit val p: Parameters) extends LogicalTreeNode(() => Some(device)) {
-  /**
-   * Translate register field offsets to account for the fact that the dmOuter
-   * registers are offset from the base DebugModule address.
-   *
-   * Although the rocket-chip regmap helper takes offsets that are relative to
-   * the base of the register address block, for the Object Model we have
-   * decided to collapse the two separate DebugModule register address blocks
-   * into a single one, so we need to account for the dmOuter offset.
-   */
-  private def translateDMOuterRegisterOffsets(regMap: OMRegisterMap): OMRegisterMap = {
-    val addressSets = dmOuter().dmOuter.dmiNode.address
-    addressSets.foreach { addressSet =>
-      require(
-        addressSet.contiguous,
-        s"DebugLogicalTree address logic currently assumes contiguous AddressSets; ${addressSet} is not contiguous"
-      )
-    }
-
-    val baseAddressBytes = addressSets.map(_.base).reduceLeft(_ min _)
-
-    regMap.copy(
-      registerFields = regMap.registerFields.map(
-        field => field.copy(
-          bitRange = field.bitRange.copy(
-            base = field.bitRange.base + baseAddressBytes * 8
-          )
-        )
-      )
-    )
-  }
-
-  def getOMDebug(resourceBindings: ResourceBindings): Seq[OMComponent] = {
-    val nComponents: Int = dmOuter().dmOuter.module.getNComponents()
-    val needCustom: Boolean = dmInner().dmInner.module.getNeedCustom()
-    val omInnerRegMap: OMRegisterMap = dmInner().dmInner.module.omRegMap
-    val omOuterRegMap: OMRegisterMap = translateDMOuterRegisterOffsets(dmOuter().dmOuter.module.omRegMap)
-    val cfg: DebugModuleParams = dmInner().dmInner.getCfg()
-
-    val omRegMap = OMRegisterMap(
-      registerFields = omInnerRegMap.registerFields ++ omOuterRegMap.registerFields,
-      groups = omInnerRegMap.groups ++ omOuterRegMap.groups
-    )
-
-    val memRegions :Seq[OMMemoryRegion] = DiplomaticObjectModelAddressing
-      .getOMMemoryRegions("Debug", resourceBindings, Some(omRegMap))
-
-    Seq[OMComponent](
-      OMDebug(
-        memoryRegions = memRegions,
-        interrupts = Nil,
-        specifications = List(
-          OMSpecification(
-            name = "The RISC-V Debug Specification",
-            version = "0.13"
-          )
-        ),
-        interfaceType = OMDebug.getOMDebugInterfaceType(p),
-        nSupportedHarts = nComponents,
-        nAbstractDataWords = cfg.nAbstractDataWords,
-        nProgramBufferWords = cfg.nProgramBufferWords,
-        nDMIAddressSizeBits = cfg.nDMIAddrSize,
-        hasSystemBusAccess = cfg.hasBusMaster,
-        supportsQuickAccess = cfg.supportQuickAccess,
-        supportsHartArray = cfg.supportHartArray,
-        hasImplicitEbreak = cfg.hasImplicitEbreak,
-        sbcsSBAVersion = 1,
-        sbaAddressSizeBits = cfg.maxSupportedSBAccess,
-        hasSBAccess8 = cfg.maxSupportedSBAccess >= 8,
-        hasSBAccess16 = cfg.maxSupportedSBAccess >= 16,
-        hasSBAccess32 = cfg.maxSupportedSBAccess >= 32,
-        hasSBAccess64 = cfg.maxSupportedSBAccess >= 64,
-        hasSBAccess128 = cfg.maxSupportedSBAccess == 128,
-        hartSeltoHartIDMapping = Nil, // HartSel goes from 0->N but HartID is not contiguious or increasing
-        authenticationType = (if (cfg.hasAuthentication) PASSTHRU else NONE),
-        nHartsellenBits = p(MaxHartIdBits), // Number of actually implemented bits of Hartsel
-        hasHartInfo = cfg.atzero,
-        hasAbstractauto = true,
-        cfgStrPtrValid = false,
-        nHaltSummaryRegisters = 2,
-        nHaltGroups = cfg.nHaltGroups,
-        nExtTriggers = cfg.nExtTriggers,
-        hasResetHaltReq = true,
-        hasHartReset = cfg.hasHartResets,
-        hasAbstractAccessFPU = false,
-        hasAbstractAccessCSR = false,
-        hasAbstractAccessMemory = false,
-        hasCustom = needCustom,
-        hasAbstractPostIncrement = false,
-        hasAbstractPostExec = true,
-        hasClockGate = cfg.clockGate,
-        crossingHasSafeReset = cfg.crossingHasSafeReset
-    )
-    )
-  }
-
-  def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    DiplomaticObjectModelAddressing.getOMComponentHelper(resourceBindings, getOMDebug)
-  }
-}
-
-class PLICLogicalTreeNode(
-  device: => SimpleDevice,
-  omRegMap: => OMRegisterMap,
-  nPriorities: => Int,
-  nInterrupts: => Int) extends LogicalTreeNode(() => Some(device)) {
-  def getOMPLIC(resourceBindings: ResourceBindings): Seq[OMComponent] = {
-    val memRegions : Seq[OMMemoryRegion]= DiplomaticObjectModelAddressing.getOMMemoryRegions("PLIC", resourceBindings, Some(omRegMap))
-    val Description(name, mapping) = device.describe(resourceBindings)
-    val ints = DiplomaticObjectModelAddressing.describeInterrupts(name, resourceBindings)
-    val targets = getInterruptTargets(resourceBindings)
-
-    Seq[OMComponent](
-      OMPLIC(
-        memoryRegions = memRegions,
-        interrupts = ints,
-        specifications = List(
-          OMSpecification(
-            name = "The RISC-V Instruction Set Manual, Volume II: Privileged Architecture",
-            version = "1.10"
-          )
-        ),
-        latency = 2, // TODO
-        nPriorities = nPriorities,
-        nInterrupts = nInterrupts,
-        targets = targets
-      )
-    )
-  }
-
-  private def getInterruptTargets(resourceBindings: ResourceBindings): Seq[OMInterruptTarget] = {
-    case class InterruptTarget(device: Device, numberAtReceiver: BigInt)
-
-    // Can't pattern match on BigInts using integer literals, so we define
-    // BigInts to match against.
-    // These match the RISC-V Privileged ISA spec mcause values.
-    val UserMode = BigInt(8)
-    val SupervisorMode = BigInt(9)
-    val MachineMode = BigInt(11)
-
-    val int = resourceBindings("int")
-    val interruptTargets = int.map {
-      case Binding(Some(device), ResourceInt(numberAtReceiver)) =>
-        InterruptTarget(device, numberAtReceiver)
-      case b: Binding => throw new Exception(s"Unexpected binding: $b")
-    }
-    interruptTargets.groupBy(_.device).map { case (device, targets) =>
-      // The interrupt resource bindings on the PLIC actually point to an
-      // intermediate SinksExternalInterrupts node, and we have to follow it one
-      // more level to get to the actual Device pointing to CPU core.
-      val coreDevice = device.parent.get.asInstanceOf[SimpleDevice]
-      // We expect the deviceNamePlusAddress to look like "cpu@0"
-      val hartId = coreDevice.deviceNamePlusAddress.split("@").last.toInt
-      val modes = targets.map {
-        case InterruptTarget(_, UserMode) => OMUserMode
-        case InterruptTarget(_, SupervisorMode) => OMSupervisorMode
-        case InterruptTarget(_, MachineMode) => OMMachineMode
-        case InterruptTarget(_, i) => throw new Exception(s"Unexpected interrupt number: $i")
-      }
-
-      OMInterruptTarget(hartId = hartId, modes = modes)
-    }.toSeq.sortBy(_.hartId)
-  }
-
-  def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    DiplomaticObjectModelAddressing.getOMComponentHelper(resourceBindings, getOMPLIC)
-  }
-}
-
-class BusMemoryLogicalTreeNode(
-  device: Device,
-  omSRAMs: Seq[OMSRAM],
-  busProtocol: OMProtocol,
-  dataECC: Option[OMECC] = None,
-  hasAtomics: Option[Boolean] = None,
-  busProtocolSpecification: Option[OMSpecification] = None) extends LogicalTreeNode(() => Some(device)) {
-  def getOMBusMemory(resourceBindings: ResourceBindings): Seq[OMComponent] = {
-    val memRegions: Seq[OMMemoryRegion] = DiplomaticObjectModelAddressing.getOMMemoryRegions("OMMemory", resourceBindings, None)
-
-    val omBusMemory = OMBusMemory(
-      memoryRegions = memRegions,
-      interrupts = Nil,
-      specifications = Nil,
-      busProtocol = Some(busProtocol),
-      dataECC = dataECC.getOrElse(OMECCIdentity),
-      hasAtomics = hasAtomics.getOrElse(false),
-      memories = omSRAMs
-    )
-    Seq(omBusMemory)
-  }
-
-  def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent]): Seq[OMComponent] = {
-    DiplomaticObjectModelAddressing.getOMComponentHelper(resourceBindings, getOMBusMemory)
-  }
-}
-
-class SubsystemLogicalTreeNode(var getOMInterruptDevice: (ResourceBindings) => Seq[OMInterrupt] = (ResourceBindings) => Nil)
-  extends LogicalTreeNode(() => None) {
-  override def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    List(
-      OMCoreComplex(
-        components = components,
-        documentationName = "",
-        resetType = None
-      )
-    )
-  }
-}
-
-
-class BusErrorLogicalTreeNode(device: => SimpleDevice, f: => OMRegisterMap) extends LogicalTreeNode(() => Some(device)) {
-  def getOMBusError(resourceBindings: ResourceBindings): Seq[OMComponent] = {
-    val Description(name, mapping) = device.describe(resourceBindings)
-
-    val memRegions : Seq[OMMemoryRegion]= DiplomaticObjectModelAddressing.getOMMemoryRegions("BusError", resourceBindings, Some(f))
-
-    Seq[OMComponent](
-      OMBusError(
-        memoryRegions = memRegions,
-        interrupts = DiplomaticObjectModelAddressing.describeGlobalInterrupts(name, resourceBindings), // outgoing interrupts
-        specifications = Nil
-      )
-    )
-  }
-
-  def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    DiplomaticObjectModelAddressing.getOMComponentHelper(resourceBindings, getOMBusError)
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/logicaltree/RocketLogicalTreeNode.scala b/src/main/scala/diplomaticobjectmodel/logicaltree/RocketLogicalTreeNode.scala
deleted file mode 100644
index 92935251b8a..00000000000
--- a/src/main/scala/diplomaticobjectmodel/logicaltree/RocketLogicalTreeNode.scala
+++ /dev/null
@@ -1,161 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.logicaltree
-
-import freechips.rocketchip.diplomacy.{ResourceBindings, SimpleDevice}
-import freechips.rocketchip.diplomaticobjectmodel.DiplomaticObjectModelAddressing
-import freechips.rocketchip.diplomaticobjectmodel.model._
-import freechips.rocketchip.rocket.{DCacheParams, HellaCache, ICache, ICacheParams}
-import freechips.rocketchip.tile.{CoreParams, RocketTile}
-
-
-/**
- * Represents either a DCache or a DTIM.
- *
- * The data memory subsystem is assumed to be a DTIM if and only if deviceOpt is
- * a Some(SimpleDevice), as a DCache would not create a Device.
- */
-class DCacheLogicalTreeNode(dcache: HellaCache, deviceOpt: Option[SimpleDevice], params: DCacheParams) extends LogicalTreeNode(() => deviceOpt) {
-  def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent]): Seq[OMComponent] = {
-    deviceOpt.foreach {
-      device => require(!resourceBindings.map.isEmpty, s"""ResourceBindings map for ${device.devname} is empty""")
-    }
-    Seq(
-      OMDCache(
-        memoryRegions = DiplomaticObjectModelAddressing.getOMMemoryRegions("DTIM", resourceBindings),
-        interrupts = Nil,
-        nSets = params.nSets,
-        nWays = params.nWays,
-        blockSizeBytes = params.blockBytes,
-        dataMemorySizeBytes = params.nSets * params.nWays * params.blockBytes,
-        dataECC = params.dataECC.map(OMECC.fromString),
-        tagECC = params.tagECC.map(OMECC.fromString),
-        nTLBEntries = params.nTLBSets * params.nTLBWays,
-        nTLBSets = params.nTLBSets,
-        nTLBWays = params.nTLBWays,
-        memories = dcache.getOMSRAMs(),
-      )
-    )
-  }
-}
-
-class ICacheLogicalTreeNode(icache: ICache, deviceOpt: Option[SimpleDevice], params: ICacheParams) extends LogicalTreeNode(() => deviceOpt) {
-  override def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil): Seq[OMComponent] = {
-    Seq(
-      OMICache(
-        memoryRegions = DiplomaticObjectModelAddressing.getOMMemoryRegions("ITIM", resourceBindings),
-        interrupts = Nil,
-        nSets = params.nSets,
-        nWays = params.nWays,
-        blockSizeBytes = params.blockBytes,
-        dataMemorySizeBytes = params.nSets * params.nWays * params.blockBytes,
-        dataECC = params.dataECC.map(OMECC.fromString),
-        tagECC = params.tagECC.map(OMECC.fromString),
-        nTLBEntries = params.nTLBSets * params.nTLBWays,
-        nTLBSets = params.nTLBSets,
-        nTLBWays = params.nTLBWays,
-        maxTimSize = params.nSets * (params.nWays-1) * params.blockBytes,
-        memories = icache.module.data_arrays.map(_._2),
-      )
-    )
-  }
-}
-
-class UTLBLogicalTreeNode(coreParams: CoreParams, memories: Seq[OMSRAM]) extends LogicalTreeNode(() => None) {
-  override def getOMComponents(resourceBindings: ResourceBindings, children: Seq[OMComponent] = Nil): Seq[OMComponent] = {
-    Seq(
-      OMUTLB(
-        utlbEntries = coreParams.nL2TLBEntries,
-        memories = memories,
-      )
-    )
-  }
-}
-
-class RocketLogicalTreeNode(
-  tile: RocketTile,
-  XLen: Int,
-  PgLevels: Int
-) extends LogicalTreeNode(() => Some(tile.cpuDevice)) {
-
-  def getOMInterruptTargets(): Seq[OMInterruptTarget] = {
-    Seq(OMInterruptTarget(
-      hartId = tile.rocketParams.hartId,
-      modes = OMModes.getModes(tile.rocketParams.core.hasSupervisorMode, tile.rocketParams.core.useHypervisor)
-    ))
-  }
-
-  override def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    val rocketParams = tile.rocketParams
-    val coreParams = rocketParams.core
-
-    // Expect that one of the components passed in is the DCache/DTIM.
-    val omDCache = components.collectFirst { case x: OMDCache => x }.get
-
-    // Expect that one of the components passed in is the ICache.
-    val omICache = components.collectFirst { case x: OMICache => x }.get
-
-    // Expect that one of the components passed in is the UTLB.
-    val omUTLB = components.collectFirst { case x: OMUTLB => x }
-
-    val omBusError = components.collectFirst { case x: OMBusError => x }
-
-    Seq(OMRocketCore(
-      isa = OMISA.rocketISA(tile, XLen, PgLevels),
-      mulDiv =  coreParams.mulDiv.map{ md => OMMulDiv.makeOMI(md, XLen)},
-      fpu = coreParams.fpu.map{f => OMFPU(fLen = f.fLen, minFLen = f.minFLen)},
-      performanceMonitor = PerformanceMonitor.perfmon(coreParams),
-      pmp = OMPMP.pmp(coreParams),
-      documentationName = rocketParams.name.getOrElse("rocket"),
-      hartIds = Seq(rocketParams.hartId),
-      hasVectoredInterrupts = true,
-      interruptLatency = 4,
-      nLocalInterrupts = coreParams.nLocalInterrupts,
-      rnmiPresent = coreParams.useNMI,
-      unmiPresent = false,
-      nBreakpoints = coreParams.nBreakpoints,
-      mcontextWidth = coreParams.mcontextWidth,
-      scontextWidth = coreParams.scontextWidth,
-      branchPredictor = rocketParams.btb.map(OMBTB.makeOMI),
-      dcache = Some(omDCache),
-      icache = Some(omICache),
-      busErrorUnit = omBusError,
-      hasClockGate = coreParams.clockGate,
-      hasSCIE = coreParams.useSCIE,
-      vmPresent = coreParams.useVM,
-      utlb = omUTLB
-    ))
-  }
-}
-
-class RocketTileLogicalTreeNode(
-  getOMRocketInterruptTargets: () => Seq[OMInterruptTarget]) extends LogicalTreeNode(() => None) {
-
-  def getIndex(cs: Seq[OMComponent]): Seq[(OMComponent, Int)] = {
-    cs.zipWithIndex.filter(_._1.isInstanceOf[OMPLIC])
-  }
-
-  def updatePlic(plic: OMPLIC): OMPLIC = {
-    val omRocketInterruptTargets: Seq[OMInterruptTarget] = getOMRocketInterruptTargets()
-
-    plic.copy(targets = omRocketInterruptTargets)
-  }
-
-  def addIntsToPlic(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    val cs = getIndex(components)
-
-    require(cs.size <= 1, "Too many Plic's")
-
-    cs.flatMap {
-      case (plic, index) =>
-        val omplic = plic.asInstanceOf[OMPLIC]
-        val updatedPlic = updatePlic(omplic)
-        components.updated(index, updatedPlic)
-    }
-  }
-
-  override def getOMComponents(resourceBindings: ResourceBindings, components: Seq[OMComponent]): Seq[OMComponent] = {
-    components
-  }
-}
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/CustomISAExtensions.scala b/src/main/scala/diplomaticobjectmodel/model/CustomISAExtensions.scala
deleted file mode 100644
index 312fcc84162..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/CustomISAExtensions.scala
+++ /dev/null
@@ -1,19 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-
-trait OMCustomExtensionSpecification{
-  def name: String
-  def version: String
-  def _types: Seq[String] = Seq("OMCustomExtensionSpecification", "OMSpecification")
-}
-
-case class Xsifivecflushdlone(
-  full: Boolean = true,
-  line: Boolean = true,
-  version: String = "0.1",
-  name: String = "Cache Flush/Power Down Instructions custom extension specification",
-  override val _types: Seq[String] = Seq("OMXsifivecflushdlone", "OMCustomExtensionSpecification", "OMSpecification")
-) extends OMCustomExtensionSpecification
diff --git a/src/main/scala/diplomaticobjectmodel/model/ISASpecifications.scala b/src/main/scala/diplomaticobjectmodel/model/ISASpecifications.scala
deleted file mode 100644
index 99855feb7a5..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/ISASpecifications.scala
+++ /dev/null
@@ -1,48 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-sealed trait PrivilegedArchitectureExtension extends OMEnum
-case object MachineLevelISA extends PrivilegedArchitectureExtension
-case object HypervisorLevelISA extends PrivilegedArchitectureExtension
-case object SupervisorLevelISA extends PrivilegedArchitectureExtension
-
-object PrivilegedArchitectureExtensions {
-  val specifications = Map[PrivilegedArchitectureExtension, String](
-    MachineLevelISA -> "Machine-Level ISA",
-    HypervisorLevelISA -> "Hypervisor-Level ISA",
-    SupervisorLevelISA -> "Supervisor-Level ISA"
-  )
-
-  def specVersion(extension: PrivilegedArchitectureExtension, version: String): OMSpecification = OMSpecification(specifications(extension), version)
-}
-
-object BaseExtensions {
-  val specifications = Map[OMBaseInstructionSet, String](
-    RV32E -> "RV32E Base Integer Instruction Set",
-    RV32I -> "RV32I Base Integer Instruction Set",
-    RV64E -> "RV64E Base Integer Instruction Set",
-    RV64I -> "RV64I Base Integer Instruction Set"
-  )
-
-  def specVersion(extension: OMBaseInstructionSet, version: String): OMSpecification = OMSpecification(specifications(extension), version)
-}
-
-object ISAExtensions {
-  val specifications = Map[OMExtensionType, String](
-    M -> "M Standard Extension for Integer Multiplication and Division",
-    A -> "A Standard Extension for Atomic Instruction",
-    F -> "F Standard Extension for Single-Precision Floating-Point",
-    D -> "D Standard Extension for Double-Precision Floating-Point",
-    C -> "C Standard Extension for Compressed Instruction",
-    B -> "B Standard Extension for Bit Manipulation",
-    U -> "The RISC‑V Instruction Set Manual, Volume II: Privileged Architecture",
-    S -> "Supervisor-Level ISA",
-    H -> "H Standard Extension for Hypervisor",
-  )
-
-  def specVersion(extension: OMExtensionType, version: String): OMSpecification = OMSpecification(specifications(extension), version)
-}
-
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMAddressing.scala b/src/main/scala/diplomaticobjectmodel/model/OMAddressing.scala
deleted file mode 100644
index 9538ba667e2..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMAddressing.scala
+++ /dev/null
@@ -1,230 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.regmapper._
-
-trait OMRange extends OMCompoundType {
-  def base: BigInt
-  def size: BigInt
-}
-
-case class OMBitRange(
-  base: BigInt,
-  size: BigInt,
-  _types: Seq[String] = Seq("OMBitRange", "OMCompoundType")
-) extends OMRange
-
-case class OMAddressSet(
-  base: BigInt,
-  mask: BigInt,
-  _types: Seq[String] = Seq("OMAddressSet", "OMCompoundType")
-) extends OMCompoundType
-
-// Permissions are for memory regions
-case class OMPermissions(
-  readable: Boolean,
-  writeable: Boolean,
-  executable: Boolean,
-  cacheable: Boolean,
-  atomics: Boolean,
-  _types: Seq[String] = Seq("OMPermissions", "OMCompoundType")
-) extends OMCompoundType
-
-case class  OMRegFieldEnumeration(
-  id: BigInt,
-  name: String,
-  description: String,
-  _types: Seq[String] = Seq("OMRegFieldEnumeration", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMRegFieldDesc(
-  name: String,
-  description: String,
-  group: Option[String],
-  access: OMRegFieldAccessType,
-  wrType: Option[OMRegFieldWrType],
-  rdAction: Option[OMRegFieldRdAction],
-  volatile: Boolean,
-  resetValue: Option[BigInt],
-  enumerations: Seq[OMRegFieldEnumeration] = Seq(),
-  addressBlock: Option[String] = None,
-  // TODO: register files
-  _types: Seq[String] = Seq("OMRegFieldDesc", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMRegField (
-  bitRange: OMBitRange,
-  description: Option[OMRegFieldDesc],
-  _types: Seq[String] = Seq("OMRegField", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMRegFieldGroup (
-  name: String,
-  description: Option[String],
-  _types: Seq[String] = Seq("OMRegFieldGroup", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMAddressBlock (
-  name: String,
-  baseAddress:  BigInt, // to match the IP-XACT terminology, though this is in practice an offset
-  range: BigInt,
-  width: Int,
-  _types: Seq[String] = Seq("OMAddressBlock", "OMCompoundType")
-) extends OMCompoundType
-
-// TODO: OMRegisterFile
-
-case class OMRegisterMap (
-  registerFields: Seq[OMRegField],
-  groups: Seq[OMRegFieldGroup],
-  addressBlocks: Seq[OMAddressBlock] = Nil, // Note: this is intended to be used in the OMMemoryMap and is rather redundant here.
-  _types: Seq[String] = Seq("OMRegisterMap", "OMCompoundType")
-) extends OMCompoundType
-
-  /**
-    * A device can have multiple MemoryRegions.
-    * An example is the SPIFlash. There is a MemoryRegion for the control registers and the
-    * the actual memory mapped flash which behaves like a memory.
-    **/
-case class OMMemoryRegion (
-  name: String,
-  description: String,
-  addressSets: Seq[OMAddressSet],
-  permissions: OMPermissions,
-  // would it make more sense to add a name: Option[String] to OMAddressSet? This seems redundant
-  registerMap: Option[OMRegisterMap],
-  addressBlocks: Seq[OMAddressBlock] = Nil,
-  _types: Seq[String] = Seq("OMMemoryRegion", "OMCompoundType")
-) extends OMCompoundType
-
-object OMRegister {
-
-  private def getRegFieldAccessType(rfd: RegFieldDesc): OMRegFieldAccessType = {
-    rfd.access match {
-      case RegFieldAccessType.R => R
-      case RegFieldAccessType.W => W
-      case RegFieldAccessType.RW => RW
-    }
-  }
-
-  private def getRegFieldWrType(rfd: RegFieldDesc): Option[OMRegFieldWrType] = {
-    rfd.wrType.map {
-      wrt =>
-        wrt match {
-          case RegFieldWrType.ONE_TO_CLEAR => RFWT_ONE_TO_CLEAR
-          case RegFieldWrType.ONE_TO_SET => RFWT_ONE_TO_SET
-          case RegFieldWrType.ONE_TO_TOGGLE => RFWT_ONE_TO_TOGGLE
-          case RegFieldWrType.ZERO_TO_CLEAR => RFWT_ZERO_TO_CLEAR
-          case RegFieldWrType.ZERO_TO_SET => RFWT_ZERO_TO_SET
-          case RegFieldWrType.ZERO_TO_TOGGLE => RFWT_ZERO_TO_TOGGLE
-          case RegFieldWrType.CLEAR => RFWT_CLEAR
-          case RegFieldWrType.SET => RFWT_SET
-          case RegFieldWrType.MODIFY => RFWT_MODIFY
-        }
-    }
-  }
-
-  private def getRegFieldRdAction(rfd: RegFieldDesc): Option[OMRegFieldRdAction] = {
-    rfd.rdAction.map {
-      ra =>
-        ra match {
-          case RegFieldRdAction.CLEAR => RFRA_CLEAR
-          case RegFieldRdAction.SET => RFRA_SET
-          case RegFieldRdAction.MODIFY => RFRA_MODIFY
-        }
-    }
-  }
-
-  private def getRegFieldEnumerations(enumerations: Map[BigInt, (String, String)]): List[OMRegFieldEnumeration] = {
-    enumerations.map{
-      case (key:BigInt, (name: String, description: String)) =>
-        OMRegFieldEnumeration(
-          id = key,
-          name = name,
-          description = description
-        )
-    }.toList
-  }
-
-  private def getRegFieldDesc(rf: RegField, byteOffset: Int, bitOffset: Int): Option[OMRegFieldDesc] = {
-    rf.desc.map {
-      rfd =>
-        OMRegFieldDesc(
-          name = rfd.name,
-          description = rfd.desc,
-          group = rfd.group,
-          access = getRegFieldAccessType(rfd),
-          wrType = getRegFieldWrType(rfd),
-          rdAction = getRegFieldRdAction(rfd),
-          volatile = rfd.volatile,
-          resetValue = rfd.reset,
-          enumerations = getRegFieldEnumerations(rfd.enumerations),
-          addressBlock = rfd.addressBlock.map{_.name}
-          // TODO: register files
-        )
-    }
-  }
-
-  private def getBitRange(rf: RegField, byteOffset: Int, bitOffset: Int): OMBitRange = {
-    OMBitRange(base = (byteOffset * 8) + bitOffset, size = rf.width)
-  }
-
-  private def getRegField(rf: RegField, byteOffset: Int, bitOffset: Int): OMRegField = {
-    OMRegField (
-      bitRange = getBitRange(rf, byteOffset, bitOffset),
-      description = getRegFieldDesc(rf, byteOffset, bitOffset)
-    )
-  }
-
-  private def makeRegisters(mapping: Seq[(Int, Seq[RegField])]): Seq[OMRegField] = {
-    mapping.flatMap {
-      case (byteOffset, seq) =>
-        seq.map(_.width).scanLeft(0)(_ + _).zip(seq).map { case (bitOffset, regField) =>
-          getRegField(regField, byteOffset, bitOffset)
-        }
-    }.sortBy(_.bitRange.base).filter(_.bitRange.size > 0)
-  }
-
-  private def makeGroups(mapping: Seq[(Int, Seq[RegField])]): Seq[OMRegFieldGroup] = {
-    val groups = for {
-      (_,seq) <- mapping
-      regField <- seq
-      desc <- regField.desc
-    } yield  OMRegFieldGroup(
-      name = desc.group.getOrElse(""),
-      description = desc.groupDesc
-    )
-    groups.distinct.sortBy(_.name)
-  }
-
-  private def makeAddressBlocks(mapping: Seq[(Int, Seq[RegField])]): Seq[OMAddressBlock] = {
-    val addressBlocks = for {
-      (_,seq) <- mapping
-      regField <- seq
-      desc <- regField.desc
-      ab <- desc.addressBlock
-    } yield  OMAddressBlock(
-      name = ab.name,
-      baseAddress = ab.addressOffset,
-      range = ab.range,
-      width = ab.width
-    )
-    addressBlocks.distinct.sortBy(_.baseAddress)
-  }
-
-  private def makeRegisterMap(mapping: Seq[(Int, Seq[RegField])]): OMRegisterMap = {
-    OMRegisterMap(
-      registerFields = makeRegisters(mapping),
-      groups = makeGroups(mapping),
-      addressBlocks = makeAddressBlocks(mapping)
-    )
-  }
-
-  def convert(mapping: RegField.Map*): OMRegisterMap = {
-    makeRegisterMap(mapping)
-  }
-
-  def convertSeq(mapping: Seq[RegField.Map]): OMRegisterMap = OMRegister.convert(mapping: _*)
-
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMBase.scala b/src/main/scala/diplomaticobjectmodel/model/OMBase.scala
deleted file mode 100644
index 2f109569142..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMBase.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-trait OMBaseType
-
-trait OMEnum extends OMBaseType
-
-trait OMCompoundType extends OMBaseType
-
-trait OMComponent extends OMCompoundType
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMBranchPredictor.scala b/src/main/scala/diplomaticobjectmodel/model/OMBranchPredictor.scala
deleted file mode 100644
index 47fc9a1b136..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMBranchPredictor.scala
+++ /dev/null
@@ -1,5 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-trait OMBranchPredictor extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMBusError.scala b/src/main/scala/diplomaticobjectmodel/model/OMBusError.scala
deleted file mode 100644
index a7e00f638d9..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMBusError.scala
+++ /dev/null
@@ -1,11 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-case class OMBusError(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  specifications: Seq[OMSpecification],
-  _types: Seq[String] = Seq("OMBusError", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMBusMemory.scala b/src/main/scala/diplomaticobjectmodel/model/OMBusMemory.scala
deleted file mode 100644
index 7904db02072..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMBusMemory.scala
+++ /dev/null
@@ -1,14 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMBusMemory(
-  memoryRegions: Seq[OMMemoryRegion] = Nil,
-  interrupts: Seq[OMInterrupt] = Nil,
-  specifications: Seq[OMSpecification] = Nil,
-  busProtocol: Option[OMProtocol] = None,
-  dataECC: OMECC = OMECCIdentity,
-  hasAtomics: Boolean = false,
-  memories: Seq[OMSRAM],
-  _types: Seq[String] = Seq("OMBusMemory", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMCLINT.scala b/src/main/scala/diplomaticobjectmodel/model/OMCLINT.scala
deleted file mode 100644
index 2fdc443f5d3..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMCLINT.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMCLINT(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  specifications: List[OMSpecification],
-  _types: Seq[String] = Seq("OMCLINT", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMCaches.scala b/src/main/scala/diplomaticobjectmodel/model/OMCaches.scala
deleted file mode 100644
index da101461699..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMCaches.scala
+++ /dev/null
@@ -1,79 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.util.{Code, IdentityCode, ParityCode, SECCode, SECDEDCode}
-
-trait OMCache extends OMDevice {
-  def memoryRegions(): Seq[OMMemoryRegion]
-  def interrupts(): Seq[OMInterrupt]
-  def nSets: Int
-  def nWays: Int
-  def blockSizeBytes: Int
-  def dataMemorySizeBytes: Int
-  def dataECC: Option[OMECC]
-  def tagECC: Option[OMECC]
-  def memories: Seq[OMSRAM]
-}
-
-case class OMICache(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  nSets: Int,
-  nWays: Int,
-  blockSizeBytes: Int,
-  dataMemorySizeBytes: Int,
-  dataECC: Option[OMECC],
-  tagECC: Option[OMECC],
-  nTLBEntries: Int,
-  nTLBSets: Int,
-  nTLBWays: Int,
-  maxTimSize: Int,
-  memories: Seq[OMSRAM],
-  _types: Seq[String] = Seq("OMICache", "OMCache", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMCache
-
-case class OMDCache(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  nSets: Int,
-  nWays: Int,
-  blockSizeBytes: Int,
-  dataMemorySizeBytes: Int,
-  dataECC: Option[OMECC],
-  tagECC: Option[OMECC],
-  nTLBEntries: Int,
-  nTLBSets: Int,
-  nTLBWays: Int,
-  memories: Seq[OMSRAM],
-  _types: Seq[String] = Seq("OMDCache", "OMCache", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMCache
-
-trait OMECC extends OMEnum
-
-case object OMECCIdentity extends OMECC
-case object OMECCParity extends OMECC
-case object OMECCSEC extends OMECC
-case object OMECCSECDED extends OMECC
-
-object OMECC {
-  def fromString(code: String): OMECC = {
-    code.toLowerCase match {
-      case "identity" => OMECCIdentity
-      case "parity"   => OMECCParity
-      case "sec"      => OMECCSEC
-      case "secded"   => OMECCSECDED
-      case _ => throw new IllegalArgumentException(s"ERROR: invalid getCode arg: $code")
-    }
-  }
-
-  def fromCode(code: Code): OMECC = {
-    code match {
-      case _: IdentityCode => OMECCIdentity
-      case _: ParityCode   => OMECCParity
-      case _: SECCode      => OMECCSEC
-      case _: SECDEDCode   => OMECCSECDED
-      case _ => throw new IllegalArgumentException(s"ERROR: invalid getCode arg: $code")
-    }
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMCore.scala b/src/main/scala/diplomaticobjectmodel/model/OMCore.scala
deleted file mode 100644
index 1698ec4b28f..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMCore.scala
+++ /dev/null
@@ -1,16 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-trait OMCore extends OMComponent{
-  def isa: OMISA
-  def mulDiv: Option[OMMulDiv]
-  def performanceMonitor: Option[OMPerformanceMonitor]
-  def pmp: Option[OMPMP]
-  def documentationName: String
-  def hartIds: Seq[Int]
-  def hasVectoredInterrupts: Boolean
-  def interruptLatency: Int
-  def nLocalInterrupts: Int
-  def nBreakpoints: Int
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMCoreComplex.scala b/src/main/scala/diplomaticobjectmodel/model/OMCoreComplex.scala
deleted file mode 100644
index 60d8c4d1248..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMCoreComplex.scala
+++ /dev/null
@@ -1,20 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-sealed trait OMCoreComplexResetType extends OMEnum
-case object CoreComplexResetTypeUnspecified extends OMCoreComplexResetType
-case object CoreComplexResetTypeSingleSynchronous extends OMCoreComplexResetType
-case object CoreComplexResetTypeSingleAsynchronous extends OMCoreComplexResetType
-case object CoreComplexResetTypeSingleAsynchronousFull extends OMCoreComplexResetType
-case object CoreComplexResetTypeSeparateCoreAndUncoreSynchronous extends OMCoreComplexResetType
-case object CoreComplexResetTypeSeparateCoreAndUncoreAsynchronous extends OMCoreComplexResetType
-case object CoreComplexResetTypeSeparateCoreAndUncoreAsynchronousFull extends OMCoreComplexResetType
-case object CoreComplexResetTypeSeparateGPRAsynchronousFull extends OMCoreComplexResetType
-
-case class OMCoreComplex(
-  components: Seq[OMComponent],
-  documentationName: String,
-  resetType: Option[OMCoreComplexResetType],
-  _types: Seq[String] = Seq("OMCoreComplex", "OMComponent", "OMCompoundType")
-) extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMDebug.scala b/src/main/scala/diplomaticobjectmodel/model/OMDebug.scala
deleted file mode 100644
index a22db441cd4..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMDebug.scala
+++ /dev/null
@@ -1,72 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-import freechips.rocketchip.config._
-import freechips.rocketchip.devices.debug.ExportDebug
-
-sealed trait OMDebugInterfaceType extends OMEnum
-case object JTAG extends OMDebugInterfaceType
-case object CJTAG extends OMDebugInterfaceType
-case object DMI extends OMDebugInterfaceType
-case object DebugAPB extends OMDebugInterfaceType
-
-sealed trait OMDebugAuthenticationType extends OMEnum
-case object NONE extends OMDebugAuthenticationType
-case object PASSTHRU extends OMDebugAuthenticationType
-
-// These directly come from RISC-V Debug Spec 0.14
-case class OMDebug(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  specifications: List[OMSpecification],
-  interfaceType: OMDebugInterfaceType,
-  nSupportedHarts: Int,
-  nAbstractDataWords: Int,
-  nProgramBufferWords: Int,
-  nDMIAddressSizeBits: Int,
-  hasSystemBusAccess: Boolean,
-  supportsQuickAccess: Boolean,
-  supportsHartArray: Boolean,
-  hasImplicitEbreak: Boolean,
-  sbcsSBAVersion: Int, // This should just always be 1. 0 has tons of issues.
-  sbaAddressSizeBits: Int,
-  hasSBAccess8: Boolean,
-  hasSBAccess16: Boolean,
-  hasSBAccess32: Boolean,
-  hasSBAccess64: Boolean,
-  hasSBAccess128: Boolean,
-  hartSeltoHartIDMapping: List[Int], // HartSel goes from 0->N but HartID is not contiguious or increasing
-  authenticationType: OMDebugAuthenticationType,
-  nHartsellenBits: Int, // Number of actually implemented bits of Hartsel
-  hasHartInfo: Boolean,
-  //supportedHartArrayWindowBits: List[Int], -- Getting rid of this because it makes no sense.
-  hasAbstractauto: Boolean,
-  cfgStrPtrValid: Boolean,
-  nHaltSummaryRegisters: Int,
-  nHaltGroups: Int,
-  nExtTriggers: Int,
-  hasResetHaltReq: Boolean,
-  hasHartReset: Boolean,
-  hasAbstractAccessFPU: Boolean,
-  hasAbstractAccessCSR: Boolean,
-  hasAbstractAccessMemory: Boolean, // There is a bunch more stuff if this is true, but we're ignoring it because we didn't and won't implement it.
-  hasCustom: Boolean, // (This makes some registers visible in the non-standard extensions range. More info would be necessary for exactly what registers)
-  hasAbstractPostIncrement: Boolean,
-  hasAbstractPostExec: Boolean,
-  hasClockGate: Boolean,
-  crossingHasSafeReset: Boolean,   // Do async crossings have "safe" reset logic
-  _types: Seq[String] = Seq("OMDebug", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
-
-object OMDebug {
-  def getOMDebugInterfaceType(p: Parameters): OMDebugInterfaceType = {
-    val export = p(ExportDebug)
-    if (export.jtag) { JTAG }
-    else if (export.cjtag) { CJTAG }
-    else if (export.dmi) { DMI }
-    else if (export.apb) { DebugAPB }
-    else { throw new IllegalArgumentException }
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMDevice.scala b/src/main/scala/diplomaticobjectmodel/model/OMDevice.scala
deleted file mode 100644
index c27d7729496..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMDevice.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-trait OMDevice extends OMComponent {
-  def memoryRegions: Seq[OMMemoryRegion]
-  def interrupts: Seq[OMInterrupt]
-}
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMErrorDevice.scala b/src/main/scala/diplomaticobjectmodel/model/OMErrorDevice.scala
deleted file mode 100644
index aa344ea8237..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMErrorDevice.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-case class OMErrorDevice(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  _types: Seq[String] = Seq("OMErrorDevice", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMFPU.scala b/src/main/scala/diplomaticobjectmodel/model/OMFPU.scala
deleted file mode 100644
index f24cbe6a2eb..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMFPU.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMFPU(
-  fLen: Int,
-  minFLen: Int,
-  _types: Seq[String] = Seq("OMFPU", "OMComponent", "OMCompoundType")
-) extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMISA.scala b/src/main/scala/diplomaticobjectmodel/model/OMISA.scala
deleted file mode 100644
index ea8ccab50ce..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMISA.scala
+++ /dev/null
@@ -1,115 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-import freechips.rocketchip.tile.RocketTile
-import freechips.rocketchip.util.BooleanToAugmentedBoolean
-
-trait OMExtensionType extends OMEnum
-case object M extends OMExtensionType
-case object A extends OMExtensionType
-case object F extends OMExtensionType
-case object D extends OMExtensionType
-case object C extends OMExtensionType
-case object B extends OMExtensionType
-case object U extends OMExtensionType
-case object S extends OMExtensionType
-case object H extends OMExtensionType
-
-trait OMAddressTranslationMode extends OMEnum
-case object Bare extends OMAddressTranslationMode
-case object Sv32 extends OMAddressTranslationMode
-case object Sv39 extends OMAddressTranslationMode
-case object Sv48 extends OMAddressTranslationMode
-// unratified/subject-to-change in the RISC-V priviledged ISA specification:
-case object Sv57 extends OMAddressTranslationMode
-
-trait OMBaseInstructionSet extends OMEnum
-case object RV32E extends OMBaseInstructionSet
-case object RV32I extends OMBaseInstructionSet
-case object RV64E extends OMBaseInstructionSet
-case object RV64I extends OMBaseInstructionSet
-case object RV128I extends OMBaseInstructionSet
-
-case class OMISA(
-  xLen: Int,
-  baseSpecification: OMSpecification,
-  base: OMBaseInstructionSet,
-  m: Option[OMSpecification],
-  a: Option[OMSpecification],
-  f: Option[OMSpecification],
-  d: Option[OMSpecification],
-  c: Option[OMSpecification],
-  b: Option[OMSpecification] = None,
-  v: Option[OMVectorExtension] = None,
-  u: Option[OMSpecification],
-  s: Option[OMSpecification],
-  h: Option[OMSpecification],
-  addressTranslationModes: Seq[OMAddressTranslationMode],
-  customExtensions: Seq[OMCustomExtensionSpecification],
-  _types: Seq[String] = Seq("OMISA", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMVectorExtension(
-  version: String,
-  vLen: Int,
-  sLen: Int,
-  eLen: Int,
-  vstartALU: Boolean, // whether non-memory/non-vsetvl instructions permit vstart != 0
-  name: String = "V Standard Extension for Vector Operations",
-  _types: Seq[String] = Seq("OMVectorExtension")
-)
-
-object OMISA {
-  def rocketISA(tile: RocketTile, xLen: Int, pgLevels: Int): OMISA = {
-    val coreParams = tile.rocketParams.core
-
-    val baseInstructionSet = xLen match {
-      case 32 => if (coreParams.useRVE) RV32E else RV32I
-      case 64 => if (coreParams.useRVE) RV64E else RV64I
-      case _ => throw new IllegalArgumentException(s"ERROR: Invalid Xlen: $xLen")
-    }
-
-    val customExtensions = {
-      if (coreParams.haveCFlush) List (Xsifivecflushdlone(full = true, line = tile.dcache.canSupportCFlushLine)) else Nil
-    }
-
-    val isaExtSpec = ISAExtensions.specVersion _
-
-    val baseSpec = BaseExtensions.specVersion _
-
-    val baseISAVersion = baseInstructionSet match {
-      case RV32E => "1.9"
-      case RV32I => "2.0"
-      case RV64E => "1.9"
-      case RV64I => "2.0"
-      case _ => throw new IllegalArgumentException(s"ERROR: Invalid baseISAVersion: $baseInstructionSet")
-    }
-
-    val addressTranslationModes = xLen match {
-      case _ if !coreParams.useVM => Bare
-      case 32 if (pgLevels == 2) => Sv32
-      case 64 if (pgLevels == 3) => Sv39
-      case 64 if (pgLevels == 4) => Sv48
-      case 64 if (pgLevels == 5) => Sv57
-      case _ => throw new IllegalArgumentException(s"ERROR: Invalid Xlen/PgLevels combination: $xLen/$pgLevels")
-    }
-
-    OMISA(
-      xLen = xLen,
-      baseSpecification = baseSpec(baseInstructionSet, baseISAVersion),
-      base = baseInstructionSet,
-      m = coreParams.mulDiv.map(x => isaExtSpec(M, "2.0")),
-      a = coreParams.useAtomics.option(isaExtSpec(A, "2.0")),
-      f = coreParams.fpu.map(x => isaExtSpec(F, "2.0")),
-      d = coreParams.fpu.filter(_.fLen > 32).map(x => isaExtSpec(D, "2.0")),
-      c = coreParams.useCompressed.option(isaExtSpec(C, "2.0")),
-      u = (coreParams.hasSupervisorMode || coreParams.useUser).option(isaExtSpec(U, "1.10")),
-      s = coreParams.hasSupervisorMode.option(isaExtSpec(S, "1.10")),
-      h = coreParams.useHypervisor.option(isaExtSpec(H, "0.6")),
-      addressTranslationModes = Seq(addressTranslationModes),
-      customExtensions = customExtensions
-    )
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMInterrupts.scala b/src/main/scala/diplomaticobjectmodel/model/OMInterrupts.scala
deleted file mode 100644
index f7518666aa4..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMInterrupts.scala
+++ /dev/null
@@ -1,11 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMInterrupt(
-  receiver: String, // TODO Reference
-  numberAtReceiver: BigInt,
-  name: String,
-  _types: Seq[String] = Seq("OMInterrupt", "OMCompoundType")
-)  extends OMCompoundType
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMMemory.scala b/src/main/scala/diplomaticobjectmodel/model/OMMemory.scala
deleted file mode 100644
index 2bc536019bc..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMMemory.scala
+++ /dev/null
@@ -1,13 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMMemory(
-  description: String,
-  addressWidth: Int,
-  dataWidth: Int,
-  depth: BigInt,
-  writeMaskGranularity: Int,
-  _types: Seq[String] = Seq("OMMemory")
-)
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMMulDiv.scala b/src/main/scala/diplomaticobjectmodel/model/OMMulDiv.scala
deleted file mode 100644
index 4ee0edb9f80..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMMulDiv.scala
+++ /dev/null
@@ -1,45 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.rocket.MulDivParams
-
-case class OMMulDiv(
-  divideBitsPerCycle: Int,
-  divideMaxLatency: Int,
-  divideMinLatency: Int,
-  multiplyBitsPerCycle: Int,
-  multiplyFullyPipelined: Boolean,
-  multiplyMaxLatency: Int,
-  multiplyMinLatency: Int,
-  _types: Seq[String] = Seq("OMMulDiv", "OMComponent", "OMCompoundType")
-) extends OMComponent
-
-
-object OMMulDiv {
-  def makeOMI(md: MulDivParams, xLen: Int): OMMulDiv = {
-    val mulMinLatency =
-      if (md.mulUnroll > 0) {
-        if (md.mulEarlyOut) { 2 }
-        else { xLen/md.mulUnroll }
-      }
-      else { xLen }
-
-    val divMinLatency =
-      if (md.divUnroll > 0) {
-        if (md.divEarlyOut) { 3 }
-        else { 2 }
-      }
-      else { xLen }
-
-    OMMulDiv(
-      divideBitsPerCycle = md.divUnroll,
-      divideMaxLatency = xLen / md.divUnroll,
-      divideMinLatency = divMinLatency,
-      multiplyBitsPerCycle = md.mulUnroll,
-      multiplyFullyPipelined = md.mulUnroll == xLen,
-      multiplyMaxLatency = xLen / md.mulUnroll,
-      multiplyMinLatency = mulMinLatency
-    )
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMPLIC.scala b/src/main/scala/diplomaticobjectmodel/model/OMPLIC.scala
deleted file mode 100644
index 1f4d8df74f0..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMPLIC.scala
+++ /dev/null
@@ -1,34 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-sealed trait OMPrivilegeMode extends OMEnum
-case object OMMachineMode extends OMPrivilegeMode
-case object OMHypervisorMode extends OMPrivilegeMode
-case object OMSupervisorMode extends OMPrivilegeMode
-case object OMUserMode extends OMPrivilegeMode
-
-object OMModes {
-  def getModes(hasSupervisorMode: Boolean, hasHypervisorMode: Boolean): Seq[OMPrivilegeMode] = {
-    Seq(OMMachineMode) ++
-    (if (hasHypervisorMode) Seq(OMHypervisorMode) else Seq()) ++
-    (if (hasSupervisorMode) Seq(OMSupervisorMode) else Seq())
-  }
-}
-
-case class OMInterruptTarget(
-  hartId: Int,
-  modes: Seq[OMPrivilegeMode],
-  _types: Seq[String] = Seq("OMInterruptTarget", "OMCompoundType")
-) extends OMCompoundType
-
-case class OMPLIC(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  specifications: Seq[OMSpecification],
-  latency: Int,
-  nPriorities: Int,
-  nInterrupts: Int,
-  targets: Seq[OMInterruptTarget],
-  _types: Seq[String] = Seq("OMPLIC", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMPMP.scala b/src/main/scala/diplomaticobjectmodel/model/OMPMP.scala
deleted file mode 100644
index 0faf91edaad..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMPMP.scala
+++ /dev/null
@@ -1,27 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.rocket.RocketCoreParams
-
-case class OMPMP(
-  specifications: Seq[OMSpecification],
-  nRegions: Int,
-  granularity: Int,
-  _types: Seq[String] = Seq("OMPMP", "OMComponent", "OMCompoundType")
-) extends OMComponent
-
-object OMPMP {
-  def pmp(coreParams: RocketCoreParams): Option[OMPMP] = {
-    if (coreParams.pmpGranularity > 0 || coreParams.nPMPs > 0) {
-      Some(OMPMP(
-        specifications = List[OMSpecification](PrivilegedArchitectureExtensions.specVersion(MachineLevelISA, "1.10")),
-        nRegions = coreParams.nPMPs,
-        granularity = coreParams.pmpGranularity
-      ))
-    }
-    else {
-      None
-    }
-  }
-}
\ No newline at end of file
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMPerformanceMonitor.scala b/src/main/scala/diplomaticobjectmodel/model/OMPerformanceMonitor.scala
deleted file mode 100644
index 03256b02e03..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMPerformanceMonitor.scala
+++ /dev/null
@@ -1,27 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.rocket.RocketCoreParams
-
-case class OMPerformanceMonitor(
-  specifications: List[OMSpecification],
-  hasBasicCounters: Boolean,
-  nAdditionalCounters: Int,
-  _types: Seq[String] = Seq("OMPerformanceMonitor", "OMComponent", "OMCompoundType")
-) extends OMComponent
-
-object PerformanceMonitor {
-  def perfmon(coreParams: RocketCoreParams): Option[OMPerformanceMonitor] = {
-    if (coreParams.haveBasicCounters || coreParams.nPerfCounters > 0) {
-      Some(OMPerformanceMonitor(
-        specifications = List[OMSpecification](PrivilegedArchitectureExtensions.specVersion(MachineLevelISA, "1.10")),
-        hasBasicCounters = coreParams.haveBasicCounters,
-        nAdditionalCounters = coreParams.nPerfCounters
-      ))
-    }
-    else {
-      None
-    }
-  }
-}
\ No newline at end of file
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMPorts.scala b/src/main/scala/diplomaticobjectmodel/model/OMPorts.scala
deleted file mode 100644
index 4b464f0d0ea..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMPorts.scala
+++ /dev/null
@@ -1,228 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.diplomacy.{ResourceBindings, IdRange, IdMapEntry}
-import freechips.rocketchip.diplomaticobjectmodel.DiplomaticObjectModelAddressing
-
-sealed trait PortType extends OMEnum
-case object SystemPortType extends PortType
-case object PeripheralPortType extends PortType
-case object MemoryPortType extends PortType
-case object FrontPortType extends PortType
-
-sealed trait ProtocolType extends OMEnum
-case object AXI4Protocol extends ProtocolType
-case object AHBProtocol extends ProtocolType
-case object APBProtocol extends ProtocolType
-case object TLProtocol extends ProtocolType
-
-sealed trait SubProtocolType extends OMEnum
-trait AXI4SubProtocol extends SubProtocolType
-trait AHBSubProtocol extends SubProtocolType
-trait APBSubProtocol extends SubProtocolType
-trait TLSubProtocol extends SubProtocolType
-
-case object AXI4SubProtocol extends AXI4SubProtocol
-case object AXI4LiteSubProtocol extends AXI4SubProtocol
-case object AHBLiteSubProtocol extends AHBSubProtocol
-case object AHBFullSubProtocol extends AHBSubProtocol
-case object APBSubProtocol extends APBSubProtocol
-case object TL_ULSubProtocol extends TLSubProtocol
-case object TL_UHSubProtocol extends TLSubProtocol
-case object TL_CSubProtocol extends TLSubProtocol
-
-trait OMProtocol extends OMCompoundType {
-  def specification: Option[OMSpecification]
-}
-
-trait AMBA extends OMProtocol
-
-case class AXI4(
-  specification: Option[OMSpecification],
-  _types: Seq[String] = Seq("AXI4", "AMBA",  "OMProtocol")
-) extends AMBA
-
-case class AXI4_Lite(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("AXI4_Lite", "AMBA",  "OMProtocol")
-) extends AMBA
-
-case class AHB_Lite(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("AHB_Lite", "AMBA",  "OMProtocol")
-) extends AMBA
-
-case class AHB(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("AHB", "AMBA",  "OMProtocol")
-) extends AMBA
-
-case class APB(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("APB", "AMBA",  "OMProtocol")
-) extends AMBA
-
-trait TL extends OMProtocol
-
-case class TL_UL(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("TL_UL", "TL",  "OMProtocol")
-) extends TL
-case class TL_UH(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("TL_UH", "TL",  "OMProtocol")
-) extends TL
-case class TL_C(
-  specification: Option[OMSpecification],
-  val _types: Seq[String] = Seq("TL_C", "TL",  "OMProtocol")
-) extends TL
-
-
-class OMIDRange (val start: Int,
-                 val end: Int,
-                 val _types: Seq[String] = Seq("OMIDRange", "OMCompundType"))
-object OMIDRange {
-  def apply(i: IdRange): OMIDRange = {
-    new OMIDRange(i.start, i.end)
-  }
-}
-
-class OMIDMapEntry(val name: String,
-                   val from: OMIDRange,
-                   val to: OMIDRange,
-                   val isCache: Boolean,
-                   val requestFifo: Boolean,
-                   val maxTransactionsInFlight: Option[Int],
-                   val _types: Seq[String] = Seq("OMIDMapEntry", "OMCompoundType"))
-object OMIDMapEntry {
-  def apply[T <: IdMapEntry](i: T): OMIDMapEntry = {
-    new OMIDMapEntry(i.name, OMIDRange(i.from), OMIDRange(i.to), i.isCache, i.requestFifo, i.maxTransactionsInFlight)
-  }
-}
-
-trait OMPort extends OMDevice {
-  memoryRegions: Seq[OMMemoryRegion]
-  interrupts: Seq[OMInterrupt]
-  def signalNamePrefix: String
-  def width: Int
-  def protocol: OMProtocol
-  def idMap: Seq[OMIDMapEntry]
-}
-
-trait InboundPort extends OMPort
-trait OutboundPort extends OMPort
-
-case class FrontPort(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  signalNamePrefix: String,
-  width: Int,
-  protocol: OMProtocol,
-  idMap: Seq[OMIDMapEntry],
-  _types: Seq[String] = Seq("FrontPort", "InboundPort", "OMPort", "OMDevice", "OMComponent", "OMCompoundType")
-) extends InboundPort
-
-case class MemoryPort(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  signalNamePrefix: String,
-  width: Int,
-  protocol: OMProtocol,
-  idMap: Seq[OMIDMapEntry],
-  _types: Seq[String] = Seq("MemoryPort", "OutboundPort", "OMPort", "OMDevice", "OMComponent", "OMCompoundType")) extends OutboundPort
-
-case class PeripheralPort(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  signalNamePrefix: String,
-  width: Int,
-  protocol: OMProtocol,
-  idMap: Seq[OMIDMapEntry],
-  _types: Seq[String] = Seq("PeripheralPort", "OutboundPort", "OMPort", "OMDevice", "OMComponent", "OMCompoundType")) extends OutboundPort
-
-case class SystemPort(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  signalNamePrefix: String,
-  width: Int,
-  protocol: OMProtocol,
-  idMap: Seq[OMIDMapEntry],
-  _types: Seq[String] = Seq("SystemPort", "OutboundPort", "OMPort", "OMDevice", "OMComponent", "OMCompoundType")) extends OutboundPort
-
-object OMPortMaker {
-  val protocolSpecifications = Map[(ProtocolType, SubProtocolType), String](
-   (AHBProtocol, AHBLiteSubProtocol)   -> "AHB Lite Protocol",
-   (AHBProtocol, AHBFullSubProtocol)   -> "AHB Full Protocol",
-   (AXI4Protocol, AXI4SubProtocol)     -> "AXI Protocol",
-   (AXI4Protocol, AXI4LiteSubProtocol) -> "AXI Lite Protocol",
-   (APBProtocol, APBSubProtocol)       -> "APB Protocol",
-   (TLProtocol, TL_UHSubProtocol)      -> "TileLink Protocol",
-   (TLProtocol, TL_ULSubProtocol)      -> "TileLink Protocol",
-   (TLProtocol, TL_CSubProtocol)       -> "TileLink Protocol"
- )
-
-  val protocolSpecificationVersions = Map[ProtocolType, String](
-    AHBProtocol -> "3",
-    AXI4Protocol -> "4",
-    APBProtocol -> "1.0",
-    TLProtocol -> "1.8"
-  )
-
-  def specVersion(protocol: ProtocolType, subProtocol: SubProtocolType, version: String): Option[OMSpecification] = Some(OMSpecification(protocolSpecifications(protocol, subProtocol), version))
-
-  val portNames = Map[PortType, String](
-    SystemPortType -> "System Port",
-    PeripheralPortType -> "Peripheral Port",
-    MemoryPortType -> "Memory Port",
-    FrontPortType -> "Front Port"
-  )
-
-  def port(
-    resourceBindings: Option[ResourceBindings],
-    signalNamePrefix: String,
-    portType: PortType,
-    protocol: ProtocolType,
-    subProtocol: SubProtocolType,
-    version: String,
-    beatBytes: Int,
-    idMap: Seq[OMIDMapEntry]): OMPort = {
-    val documentationName = portNames(portType)
-
-    val omProtocol = (protocol, subProtocol) match {
-      case (AXI4Protocol, AXI4SubProtocol) => AXI4(specification = specVersion(protocol, subProtocol, version))
-      case (AXI4Protocol, AXI4LiteSubProtocol) => AXI4_Lite(specification = specVersion(protocol, subProtocol, version))
-      case (AHBProtocol, AHBLiteSubProtocol) => AHB_Lite(specification = specVersion(protocol, subProtocol, version))
-      case (AHBProtocol, AHBFullSubProtocol) => AHB(specification = specVersion(protocol, subProtocol, version))
-      case (APBProtocol, APBSubProtocol) => APB(specification = specVersion(protocol, subProtocol, version))
-      case (TLProtocol, TL_UHSubProtocol) => TL_UH(specification = specVersion(protocol, subProtocol, version))
-      case (TLProtocol, TL_ULSubProtocol) => TL_UL(specification = specVersion(protocol, subProtocol, version))
-      case (TLProtocol, TL_CSubProtocol) => TL_C(specification = specVersion(protocol, subProtocol, version))
-      case _ => throw new IllegalArgumentException(s"protocol $protocol, subProtocol $subProtocol")
-    }
-
-    resourceBindings match {
-      case Some(rb) =>
-        val memRegions = DiplomaticObjectModelAddressing.getOMPortMemoryRegions(name = documentationName, rb)
-        portType match {
-          case SystemPortType => SystemPort(memoryRegions = memRegions, interrupts = Nil, signalNamePrefix = signalNamePrefix,
-            width = beatBytes * 8, protocol = omProtocol, idMap = idMap)
-          case PeripheralPortType => PeripheralPort(memoryRegions = memRegions, interrupts = Nil, signalNamePrefix = signalNamePrefix,
-            width = beatBytes * 8, protocol = omProtocol, idMap = idMap)
-          case MemoryPortType => MemoryPort(memoryRegions = memRegions, interrupts = Nil, signalNamePrefix = signalNamePrefix,
-            width = beatBytes * 8, protocol = omProtocol, idMap = idMap)
-          case FrontPortType => throw new IllegalArgumentException
-          case _ => throw new IllegalArgumentException
-        }
-      case None => {
-        portType match {
-          case FrontPortType => FrontPort(memoryRegions = Nil, interrupts = Nil,
-            signalNamePrefix = signalNamePrefix, width = beatBytes * 8, protocol = omProtocol, idMap = idMap)
-          case _ => throw new IllegalArgumentException
-        }
-      }
-    }
-  }
-}
-
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMRTLModule.scala b/src/main/scala/diplomaticobjectmodel/model/OMRTLModule.scala
deleted file mode 100644
index 2db796aa04d..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMRTLModule.scala
+++ /dev/null
@@ -1,62 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-trait RTLComponent extends OMCompoundType
-
-trait OMSignal extends RTLComponent {
-  def name: String // This will always be the name of the signal on the top-level module
-  def description: Option[String]
-}
-
-case class OMClock(
-  name: String,
-  description: Option[String]
-) extends OMSignal
-
-case class OMClockRelationship(
-  clock0: String,
-  clock1: String,
-  relationship: String,
-) extends RTLComponent
-
-trait OMSignalAssertionLevel extends OMEnum
-trait High extends OMSignalAssertionLevel
-trait Low extends OMSignalAssertionLevel
-
-trait Synchronicity extends OMEnum
-trait Synchronous extends Synchronicity
-trait Asynchronous extends Synchronicity
-
-case class OMRTLReset(
-  activeEdge: Option[OMSignalAssertionLevel],
-  clock: String, // This will always be the name of the clock signal on the to p-level module
-  synchronicity: Option[Synchronicity]
-)
-
-case class OMResetVector(
-  width: Int
-)
-
-case class OMRTLInterface(
-  clocks: List[OMClock],
-  clockRelationships: List[OMClockRelationship],
-  resets: List[OMRTLReset],
-  _types: Seq[String] = Seq("OMRTLInterface")
-) extends RTLComponent
-
-
-/*********************************************************
-  * Describe an RTL module
-  * RTL modules may be transformed, renamed or even removed by subsequent optimizations.
-  * Thus, "moduleName" is only a suggested name which may not correspond to any of the final module names.
-  * For convenience, there are default values for all fields. It is reasonable to use "OMRTLModule()"
-  * as a placeholder when an rtl module is required but the information isn't known.
-  */
-case class  OMRTLModule(
-  moduleName: String = "",
-  instanceName: Option[String] = None,  // TODO: This does not exist for the top-level module because the top-level module is the only one that is not instantiated
-  hierarchicalId: Option[String] = None,  // Full dotted path from the root, where the root is described as a module name while all other path components are instance names
-  interface: OMRTLInterface = OMRTLInterface(List(), List(), List()),
-  _types: Seq[String] = Seq("OMRTLModule", "OMRTLComponent")
-)
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldAccessType.scala b/src/main/scala/diplomaticobjectmodel/model/OMRegFieldAccessType.scala
deleted file mode 100644
index 1a5f2de3fd3..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldAccessType.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-sealed trait OMRegFieldAccessType extends OMEnum
-case object R  extends OMRegFieldAccessType
-case object W  extends OMRegFieldAccessType
-case object RW extends OMRegFieldAccessType
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldRdAction.scala b/src/main/scala/diplomaticobjectmodel/model/OMRegFieldRdAction.scala
deleted file mode 100644
index 7d734d6e88b..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldRdAction.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-sealed trait OMRegFieldRdAction extends OMEnum
-case object RFRA_CLEAR  extends OMRegFieldRdAction
-case object RFRA_SET    extends OMRegFieldRdAction
-case object RFRA_MODIFY extends OMRegFieldRdAction
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldWrType.scala b/src/main/scala/diplomaticobjectmodel/model/OMRegFieldWrType.scala
deleted file mode 100644
index 2e6751dcdaa..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMRegFieldWrType.scala
+++ /dev/null
@@ -1,16 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-/* The following enum names come from IP-XACT */
-sealed trait OMRegFieldWrType extends OMEnum
-case object RFWT_ONE_TO_CLEAR   extends OMRegFieldWrType
-case object RFWT_ONE_TO_SET     extends OMRegFieldWrType
-case object RFWT_ONE_TO_TOGGLE  extends OMRegFieldWrType
-case object RFWT_ZERO_TO_CLEAR  extends OMRegFieldWrType
-case object RFWT_ZERO_TO_SET    extends OMRegFieldWrType
-case object RFWT_ZERO_TO_TOGGLE extends OMRegFieldWrType
-case object RFWT_CLEAR          extends OMRegFieldWrType
-case object RFWT_SET            extends OMRegFieldWrType
-case object RFWT_MODIFY         extends OMRegFieldWrType
-
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMRocketCore.scala b/src/main/scala/diplomaticobjectmodel/model/OMRocketCore.scala
deleted file mode 100644
index f4ed954e1b4..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMRocketCore.scala
+++ /dev/null
@@ -1,49 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-import freechips.rocketchip.rocket.BTBParams
-
-case class OMRocketBranchPredictor(
-  nBtbEntries: Int,
-  nBhtEntries: Int,
-  nRasEntries: Int,
-  _types: Seq[String] = Seq("OMRocketBranchPredictor", "OMBranchPredictor", "OMComponent", "OMCompoundType")
-) extends OMBranchPredictor
-
-case class OMRocketCore(
-  isa: OMISA,
-  mulDiv: Option[OMMulDiv],
-  fpu: Option[OMFPU],
-  performanceMonitor: Option[OMPerformanceMonitor],
-  pmp: Option[OMPMP],
-  documentationName: String,
-  hartIds: Seq[Int],
-  hasVectoredInterrupts: Boolean,
-  interruptLatency: Int,
-  nLocalInterrupts: Int,
-  rnmiPresent: Boolean,
-  unmiPresent: Boolean,
-  nBreakpoints: Int,
-  mcontextWidth: Int,
-  scontextWidth: Int,
-  branchPredictor: Option[OMRocketBranchPredictor],
-  dcache: Option[OMDCache],
-  icache: Option[OMICache],
-  busErrorUnit: Option[OMBusError],
-  hasClockGate: Boolean,
-  hasSCIE: Boolean,
-  vmPresent: Boolean,
-  utlb: Option[OMUTLB],
-  _types: Seq[String] = Seq("OMRocketCore", "OMCore", "OMComponent", "OMCompoundType")
-) extends OMCore
-
-object OMBTB {
-  def makeOMI(p: BTBParams): OMRocketBranchPredictor = {
-    OMRocketBranchPredictor(
-      nBtbEntries = p.nEntries,
-      nBhtEntries = p.bhtParams.map(_.nEntries).getOrElse(0),
-      nRasEntries = p.nRAS
-    )
-  }
-}
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMSRAM.scala b/src/main/scala/diplomaticobjectmodel/model/OMSRAM.scala
deleted file mode 100644
index cc42205e3f0..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMSRAM.scala
+++ /dev/null
@@ -1,14 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMSRAM(
-  description: String,
-  addressWidth: Int,
-  dataWidth: Int,
-  depth: BigInt,
-  writeMaskGranularity: Int,
-  uid: Int,
-  rtlModule: OMRTLModule,
-  _types: Seq[String] = Seq("OMSRAM")
-) extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMSpecification.scala b/src/main/scala/diplomaticobjectmodel/model/OMSpecification.scala
deleted file mode 100644
index a736773d2ef..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMSpecification.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMSpecification(
-  name: String,
-  version: String,
-  _types: Seq[String] = Seq("OMSpecification")
-)
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMTestHarness.scala b/src/main/scala/diplomaticobjectmodel/model/OMTestHarness.scala
deleted file mode 100644
index b1e224d490e..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMTestHarness.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-case class OMTestHarness(
-  components: Seq[OMComponent],
-  _types: Seq[String] = Seq("OMTestHarness")
-) extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMUTLB.scala b/src/main/scala/diplomaticobjectmodel/model/OMUTLB.scala
deleted file mode 100644
index 729eac98422..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMUTLB.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-case class OMUTLB(
-  utlbEntries: Int,
-  memories: Seq[OMSRAM],
-  _types: Seq[String] = Seq("OMUTLB", "OMComponent", "OMCompoundType")
-) extends OMComponent
diff --git a/src/main/scala/diplomaticobjectmodel/model/OMZeroDevice.scala b/src/main/scala/diplomaticobjectmodel/model/OMZeroDevice.scala
deleted file mode 100644
index f641ea25248..00000000000
--- a/src/main/scala/diplomaticobjectmodel/model/OMZeroDevice.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-// See LICENSE.SiFive for license details.
-
-package freechips.rocketchip.diplomaticobjectmodel.model
-
-
-case class OMZeroDevice(
-  memoryRegions: Seq[OMMemoryRegion],
-  interrupts: Seq[OMInterrupt],
-  _types: Seq[String] = Seq("OMZeroDevice", "OMDevice", "OMComponent", "OMCompoundType")
-) extends OMDevice
diff --git a/src/main/scala/rocket/DCache.scala b/src/main/scala/rocket/DCache.scala
index 951803adc36..3e8ebf833b5 100644
--- a/src/main/scala/rocket/DCache.scala
+++ b/src/main/scala/rocket/DCache.scala
@@ -7,7 +7,6 @@ import Chisel.ImplicitConversions._
 import freechips.rocketchip.amba._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.model.OMSRAM
 import freechips.rocketchip.tile.{CoreBundle, LookupByHartId}
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
@@ -61,7 +60,7 @@ class DCacheDataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {
       )
   }
 
-  val rdata = for (((array, omSRAM), i) <- data_arrays zipWithIndex) yield {
+  val rdata = for ((array , i) <- data_arrays zipWithIndex) yield {
     val valid = io.req.valid && (Bool(data_arrays.size == 1) || io.req.bits.wordMask(i))
     when (valid && io.req.bits.write) {
       val wMaskSlice = (0 until wMask.size).filter(j => i % (wordBits/subWordBits) == (j % (wordBytes/eccBytes)) / (subWordBytes/eccBytes)).map(wMask(_))
@@ -84,7 +83,6 @@ class DCacheMetadataReq(implicit p: Parameters) extends L1HellaCacheBundle()(p)
 
 class DCache(staticIdForMetadataUseOnly: Int, val crossing: ClockCrossingType)(implicit p: Parameters) extends HellaCache(staticIdForMetadataUseOnly)(p) {
   override lazy val module = new DCacheModule(this)
-  override def getOMSRAMs(): Seq[OMSRAM] = Seq(module.dcacheImpl.omSRAM) ++ module.dcacheImpl.data.data_arrays.map(_._2)
 }
 
 class DCacheTLBPort(implicit p: Parameters) extends CoreBundle()(p) {
@@ -121,7 +119,7 @@ class DCacheModule(outer: DCache) extends HellaCacheModule(outer) {
   val replacer = ReplacementPolicy.fromString(cacheParams.replacementPolicy, nWays)
   val metaArb = Module(new Arbiter(new DCacheMetadataReq, 8) with InlineInstance)
 
-  val (tag_array, omSRAM) = DescribedSRAM(
+  val tag_array = DescribedSRAM(
     name = "tag_array",
     desc = "DCache Tag Array",
     size = nSets,
diff --git a/src/main/scala/rocket/Frontend.scala b/src/main/scala/rocket/Frontend.scala
index c2408d8de29..6cc6b4f8221 100644
--- a/src/main/scala/rocket/Frontend.scala
+++ b/src/main/scala/rocket/Frontend.scala
@@ -13,7 +13,6 @@ import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tile._
 import freechips.rocketchip.util._
 import freechips.rocketchip.util.property
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.ICacheLogicalTreeNode
 
 class FrontendReq(implicit p: Parameters) extends CoreBundle()(p) {
   val pc = UInt(width = vaddrBitsExtended)
@@ -380,8 +379,6 @@ trait HasICacheFrontend extends CanHavePTW { this: BaseTile =>
   // This should be a None in the case of not having an ITIM address, when we
   // don't actually use the device that is instantiated in the frontend.
   private val deviceOpt = if (tileParams.icache.get.itimAddr.isDefined) Some(frontend.icache.device) else None
-
-  val iCacheLogicalTreeNode = new ICacheLogicalTreeNode(frontend.icache, deviceOpt, tileParams.icache.get)
 }
 
 trait HasICacheFrontendModule extends CanHavePTWModule {
diff --git a/src/main/scala/rocket/HellaCache.scala b/src/main/scala/rocket/HellaCache.scala
index 8976d75eea4..ea0e3196b0c 100644
--- a/src/main/scala/rocket/HellaCache.scala
+++ b/src/main/scala/rocket/HellaCache.scala
@@ -8,7 +8,6 @@ import chisel3.dontTouch
 import freechips.rocketchip.amba._
 import freechips.rocketchip.config.{Parameters, Field}
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.model.OMSRAM
 import freechips.rocketchip.tile._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
@@ -219,8 +218,6 @@ abstract class HellaCache(staticIdForMetadataUseOnly: Int)(implicit p: Parameter
   def canSupportCFlushLine = !usingVM || cfg.blockBytes * cfg.nSets <= (1 << pgIdxBits)
 
   require(!tileParams.core.haveCFlush || cfg.scratch.isEmpty, "CFLUSH_D_L1 instruction requires a D$")
-
-  def getOMSRAMs(): Seq[OMSRAM]
 }
 
 class HellaCacheBundle(val outer: HellaCache)(implicit p: Parameters) extends CoreBundle()(p) {
diff --git a/src/main/scala/rocket/ICache.scala b/src/main/scala/rocket/ICache.scala
index 2b73ee6dd4a..5a6bc605ff2 100644
--- a/src/main/scala/rocket/ICache.scala
+++ b/src/main/scala/rocket/ICache.scala
@@ -208,7 +208,7 @@ class ICacheModule(outer: ICache) extends LazyModuleImp(outer)
     v
   }
 
-  val (tag_array, omSRAM) = DescribedSRAM(
+  val tag_array  = DescribedSRAM(
     name = "tag_array",
     desc = "ICache Tag Array",
     size = nSets,
@@ -278,7 +278,7 @@ class ICacheModule(outer: ICache) extends LazyModuleImp(outer)
       )
   }
 
-  for (((data_array, omSRAM), i) <- data_arrays zipWithIndex) {
+  for ((data_array , i) <- data_arrays zipWithIndex) {
     def wordMatch(addr: UInt) = addr.extract(log2Ceil(tl_out.d.bits.data.getWidth/8)-1, log2Ceil(wordBits/8)) === i
     def row(addr: UInt) = addr(untagBits-1, blockOffBits-log2Ceil(refillCycles))
     val s0_ren = (s0_valid && wordMatch(s0_vaddr)) || (s0_slaveValid && wordMatch(s0_slaveAddr))
diff --git a/src/main/scala/rocket/NBDcache.scala b/src/main/scala/rocket/NBDcache.scala
index f51a20d2af4..86631bd54b1 100644
--- a/src/main/scala/rocket/NBDcache.scala
+++ b/src/main/scala/rocket/NBDcache.scala
@@ -7,7 +7,6 @@ import Chisel._
 import Chisel.ImplicitConversions._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.model.OMSRAM
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
@@ -632,7 +631,7 @@ class DataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {
       val resp = Wire(Vec(rowWords, Bits(width = encRowBits)))
       val r_raddr = RegEnable(io.read.bits.addr, io.read.valid)
       for (i <- 0 until resp.size) {
-        val (array, omSRAM) = DescribedSRAM(
+        val array  = DescribedSRAM(
           name = s"array_${w}_${i}",
           desc = "Non-blocking DCache Data Array",
           size = nSets * refillCycles,
@@ -654,7 +653,7 @@ class DataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {
     }
   } else {
     for (w <- 0 until nWays) {
-      val (array, omSRAM) = DescribedSRAM(
+      val array  = DescribedSRAM(
         name = s"array_${w}",
         desc = "Non-blocking DCache Data Array",
         size = nSets * refillCycles,
@@ -674,7 +673,6 @@ class DataArray(implicit p: Parameters) extends L1HellaCacheModule()(p) {
 
 class NonBlockingDCache(staticIdForMetadataUseOnly: Int)(implicit p: Parameters) extends HellaCache(staticIdForMetadataUseOnly)(p) {
   override lazy val module = new NonBlockingDCacheModule(this)
-  override def getOMSRAMs(): Seq[OMSRAM] = Nil // this is just a dummy value and that we need to eventually fix it
 }
 
 class NonBlockingDCacheModule(outer: NonBlockingDCache) extends HellaCacheModule(outer) {
diff --git a/src/main/scala/rocket/PTW.scala b/src/main/scala/rocket/PTW.scala
index 31e410af435..c6a0cca9b0c 100644
--- a/src/main/scala/rocket/PTW.scala
+++ b/src/main/scala/rocket/PTW.scala
@@ -14,7 +14,6 @@ import freechips.rocketchip.tile._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 import freechips.rocketchip.util.property
-import freechips.rocketchip.diplomaticobjectmodel.model.OMSRAM
 import scala.collection.mutable.ListBuffer
 
 class PTWReq(implicit p: Parameters) extends CoreBundle()(p) {
@@ -123,8 +122,6 @@ class PTW(n: Int)(implicit edge: TLEdgeOut, p: Parameters) extends CoreModule()(
     val dpath = new DatapathPTWIO
   }
 
-  val omSRAMs = collection.mutable.ListBuffer[OMSRAM]()
-
   val s_ready :: s_req :: s_wait1 :: s_dummy1 :: s_wait2 :: s_wait3 :: s_dummy2 :: s_fragment_superpage :: Nil = Enum(UInt(), 8)
   val state = Reg(init=s_ready)
   val l2_refill_wire = Wire(Bool())
@@ -279,7 +276,7 @@ class PTW(n: Int)(implicit edge: TLEdgeOut, p: Parameters) extends CoreModule()(
 
     val l2_plru = new SetAssocLRU(nL2TLBSets, coreParams.nL2TLBWays, "plru")
 
-    val (ram, omSRAM) =  DescribedSRAM(
+    val ram =  DescribedSRAM(
       name = "l2_tlb_ram",
       desc = "L2 TLB",
       size = nL2TLBSets,
@@ -351,7 +348,6 @@ class PTW(n: Int)(implicit edge: TLEdgeOut, p: Parameters) extends CoreModule()(
       ccover(s2_hit && s2_hit_vec(way), s"L2_TLB_HIT_WAY$way", s"L2 TLB hit way$way")
     }
 
-    omSRAMs += omSRAM
     (s2_hit, s2_error, s2_pte, Some(ram))
   }
 
@@ -605,7 +601,6 @@ class PTW(n: Int)(implicit edge: TLEdgeOut, p: Parameters) extends CoreModule()(
 /** Mix-ins for constructing tiles that might have a PTW */
 trait CanHavePTW extends HasTileParameters with HasHellaCache { this: BaseTile =>
   val module: CanHavePTWModule
-  val utlbOMSRAMs = collection.mutable.ListBuffer[OMSRAM]()
   var nPTWPorts = 1
   nDCachePorts += usingPTW.toInt
 }
@@ -616,6 +611,5 @@ trait CanHavePTWModule extends HasHellaCacheModule {
   val ptw = Module(new PTW(outer.nPTWPorts)(outer.dcache.node.edges.out(0), outer.p))
   if (outer.usingPTW) {
     dcachePorts += ptw.io.mem
-    outer.utlbOMSRAMs ++= ptw.omSRAMs
   }
 }
diff --git a/src/main/scala/subsystem/Attachable.scala b/src/main/scala/subsystem/Attachable.scala
index d7f3505f5cc..a5301600698 100644
--- a/src/main/scala/subsystem/Attachable.scala
+++ b/src/main/scala/subsystem/Attachable.scala
@@ -4,7 +4,6 @@ package freechips.rocketchip.subsystem
 
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy.{LazyModule, LazyScope}
-import freechips.rocketchip.diplomaticobjectmodel.HasLogicalTreeNode
 import freechips.rocketchip.prci.ClockGroupEphemeralNode
 import freechips.rocketchip.tilelink.TLBusWrapper
 import freechips.rocketchip.util.{Location, LocationMap}
@@ -22,11 +21,8 @@ trait LazyScopeWithParameters extends LazyScope { this: LazyModule =>
   implicit val p: Parameters
 }
 
-/** Layers of hierarchy with this trait will be represented as objects in the Object Model */
-trait HasLogicalHierarchy extends LazyScopeWithParameters with HasLogicalTreeNode { this: LazyModule => }
-
 /** Layers of hierarchy with this trait contain attachment points for neworks of power, clock, reset, and interrupt resources */
-trait HasPRCILocations extends HasLogicalHierarchy { this: LazyModule =>
+trait HasPRCILocations extends LazyScopeWithParameters { this: LazyModule =>
   implicit val asyncClockGroupsNode: ClockGroupEphemeralNode
   val ibus: InterruptBusWrapper
   val anyLocationMap = LocationMap.empty[Any]
diff --git a/src/main/scala/subsystem/BaseSubsystem.scala b/src/main/scala/subsystem/BaseSubsystem.scala
index 82ee1ec335a..4846fe60f21 100644
--- a/src/main/scala/subsystem/BaseSubsystem.scala
+++ b/src/main/scala/subsystem/BaseSubsystem.scala
@@ -5,7 +5,6 @@ package freechips.rocketchip.subsystem
 import Chisel._
 import freechips.rocketchip.config.{Field, Parameters}
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree._
 import freechips.rocketchip.prci._
 import freechips.rocketchip.tilelink.TLBusWrapper
 import freechips.rocketchip.util._
@@ -117,18 +116,6 @@ abstract class BaseSubsystem(val location: HierarchicalLocation = InSubsystem)
       }
     }
   }
-
-  lazy val logicalTreeNode = new SubsystemLogicalTreeNode()
-
-  tlBusWrapperLocationMap.values.foreach { bus =>
-    val builtIn = bus.builtInDevices
-    builtIn.errorOpt.foreach { error =>
-      LogicalModuleTree.add(logicalTreeNode, error.logicalTreeNode)
-    }
-    builtIn.zeroOpt.foreach { zero =>
-      LogicalModuleTree.add(logicalTreeNode, zero.logicalTreeNode)
-    }
-  }
 }
 
 
diff --git a/src/main/scala/subsystem/HasTiles.scala b/src/main/scala/subsystem/HasTiles.scala
index cf6143498df..2cc20030dcb 100644
--- a/src/main/scala/subsystem/HasTiles.scala
+++ b/src/main/scala/subsystem/HasTiles.scala
@@ -8,7 +8,6 @@ import freechips.rocketchip.config.{Field, Parameters}
 import freechips.rocketchip.devices.debug.{HasPeripheryDebug, HasPeripheryDebugModuleImp}
 import freechips.rocketchip.devices.tilelink.{BasicBusBlocker, BasicBusBlockerParams, CLINTConsts, PLICKey, CanHavePeripheryPLIC, CanHavePeripheryCLINT}
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{LogicalModuleTree}
 import freechips.rocketchip.interrupts._
 import freechips.rocketchip.tile.{BaseTile, LookupByHartIdImpl, TileParams, InstantiableTileParams, MaxHartIdBits, TilePRCIDomain, NMI}
 import freechips.rocketchip.tilelink._
@@ -263,7 +262,6 @@ trait CanAttachTile {
     connectPRC(domain, context)
     connectOutputNotifications(domain, context)
     connectInputConstants(domain, context)
-    LogicalModuleTree.add(context.logicalTreeNode, domain.tile.logicalTreeNode)
   }
 
   /** Connect the port where the tile is the master to a TileLink interconnect. */
diff --git a/src/main/scala/tile/BaseTile.scala b/src/main/scala/tile/BaseTile.scala
index ef4ed5e5ad0..a333912f097 100644
--- a/src/main/scala/tile/BaseTile.scala
+++ b/src/main/scala/tile/BaseTile.scala
@@ -7,8 +7,6 @@ import Chisel._
 import freechips.rocketchip.config._
 import freechips.rocketchip.subsystem._
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.{HasLogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{GenericLogicalTreeNode, LogicalTreeNode}
 
 import freechips.rocketchip.interrupts._
 import freechips.rocketchip.rocket._
@@ -186,7 +184,6 @@ abstract class BaseTile private (val crossing: ClockCrossingType, q: Parameters)
     extends LazyModule()(q)
     with CrossesToOnlyOneClockDomain
     with HasNonDiplomaticTileParameters
-    with HasLogicalTreeNode
 {
   // Public constructor alters Parameters to supply some legacy compatibility keys
   def this(tileParams: TileParams, crossing: ClockCrossingType, lookup: LookupByHartIdImpl, p: Parameters) = {
@@ -355,9 +352,6 @@ abstract class BaseTile private (val crossing: ClockCrossingType, q: Parameters)
     */
  def makeSlaveBoundaryBuffers(crossing: ClockCrossingType)(implicit p: Parameters) = TLBuffer(BufferParams.none)
 
-  /** Use for ObjectModel representation of this tile. Subclasses might override this. */
-  val logicalTreeNode: LogicalTreeNode = new GenericLogicalTreeNode
-
   /** Can be used to access derived params calculated by HasCoreParameters
     *
     * However, callers must ensure they do not access a diplomatically-determined parameter
diff --git a/src/main/scala/tile/BusErrorUnit.scala b/src/main/scala/tile/BusErrorUnit.scala
index f182ee9c09b..2adb4997395 100644
--- a/src/main/scala/tile/BusErrorUnit.scala
+++ b/src/main/scala/tile/BusErrorUnit.scala
@@ -9,7 +9,6 @@ import chisel3.DontCare
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.rocket._
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusErrorLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}
 import freechips.rocketchip.regmapper._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.interrupts._
@@ -35,7 +34,7 @@ class L1BusErrors(implicit p: Parameters) extends CoreBundle()(p) with BusErrors
 
 case class BusErrorUnitParams(addr: BigInt, size: Int = 4096)
 
-class BusErrorUnit[T <: BusErrors](t: => T, params: BusErrorUnitParams, logicalTreeNode: LogicalTreeNode)(implicit p: Parameters) extends LazyModule {
+class BusErrorUnit[T <: BusErrors](t: => T, params: BusErrorUnitParams)(implicit p: Parameters) extends LazyModule {
   val regWidth = 64
   val device = new SimpleDevice("bus-error-unit", Seq("sifive,buserror0"))
   val intNode = IntSourceNode(IntSourcePortSimple(resources = device.int))
@@ -130,8 +129,5 @@ class BusErrorUnit[T <: BusErrors](t: => T, params: BusErrorUnitParams, logicalT
       accrued(i) := false
       local_interrupt(i) := false
     }
-
-    val busErrorLTN = new BusErrorLogicalTreeNode(device, omRegMap)
-    LogicalModuleTree.add(logicalTreeNode, busErrorLTN)
   }
 }
diff --git a/src/main/scala/tile/RocketTile.scala b/src/main/scala/tile/RocketTile.scala
index 71d2e5673f1..619c9debdab 100644
--- a/src/main/scala/tile/RocketTile.scala
+++ b/src/main/scala/tile/RocketTile.scala
@@ -7,7 +7,6 @@ import Chisel._
 import freechips.rocketchip.config._
 import freechips.rocketchip.devices.tilelink._
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{DCacheLogicalTreeNode, LogicalModuleTree, RocketLogicalTreeNode, UTLBLogicalTreeNode}
 import freechips.rocketchip.interrupts._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.rocket._
@@ -56,15 +55,13 @@ class RocketTile private(
   val slaveNode = TLIdentityNode()
   val masterNode = visibilityNode
 
-  override val logicalTreeNode = new RocketLogicalTreeNode(this, p(XLen), pgLevels)
-
   val dtim_adapter = tileParams.dcache.flatMap { d => d.scratch.map { s =>
     LazyModule(new ScratchpadSlavePort(AddressSet.misaligned(s, d.dataScratchpadBytes), lazyCoreParamsView.coreDataBytes, tileParams.core.useAtomics && !tileParams.core.useAtomicsOnlyForIO))
   }}
   dtim_adapter.foreach(lm => connectTLSlave(lm.node, lm.node.portParams.head.beatBytes))
 
   val bus_error_unit = rocketParams.beuAddr map { a =>
-    val beu = LazyModule(new BusErrorUnit(new L1BusErrors, BusErrorUnitParams(a), logicalTreeNode))
+    val beu = LazyModule(new BusErrorUnit(new L1BusErrors, BusErrorUnitParams(a)))
     intOutwardNode := beu.intNode
     connectTLSlave(beu.node, xBytes)
     beu
@@ -120,15 +117,6 @@ class RocketTile private(
       else TLBuffer(BufferParams.flow, BufferParams.none, BufferParams.none, BufferParams.none, BufferParams.none)
     case _ => TLBuffer(BufferParams.none)
   }
-
-  val dCacheLogicalTreeNode = new DCacheLogicalTreeNode(dcache, dtim_adapter.map(_.device), rocketParams.dcache.get)
-  LogicalModuleTree.add(logicalTreeNode, iCacheLogicalTreeNode)
-  LogicalModuleTree.add(logicalTreeNode, dCacheLogicalTreeNode)
-
-  if (rocketParams.core.useVM) {
-    val utlbLogicalTreeNode = new UTLBLogicalTreeNode(rocketParams.core, utlbOMSRAMs)
-    LogicalModuleTree.add(logicalTreeNode, utlbLogicalTreeNode)
-  }
 }
 
 class RocketTileModuleImp(outer: RocketTile) extends BaseTileModuleImp(outer)
diff --git a/src/main/scala/tilelink/RegisterRouter.scala b/src/main/scala/tilelink/RegisterRouter.scala
index ebc524437d4..d5d5cb49c00 100644
--- a/src/main/scala/tilelink/RegisterRouter.scala
+++ b/src/main/scala/tilelink/RegisterRouter.scala
@@ -6,7 +6,6 @@ import Chisel._
 import chisel3.RawModule
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.model.{OMRegister, OMRegisterMap}
 import freechips.rocketchip.regmapper._
 import freechips.rocketchip.util._
 
@@ -61,7 +60,7 @@ case class TLRegisterNode(
 
   // Calling this method causes the matching TL2 bundle to be
   // configured to route all requests to the listed RegFields.
-  def regmap(mapping: RegField.Map*) : OMRegisterMap = {
+  def regmap(mapping: RegField.Map*) = {
     val (bundleIn, edge) = this.in(0)
     val a = bundleIn.a
     val d = bundleIn.d
@@ -103,11 +102,6 @@ case class TLRegisterNode(
     bundleIn.e.ready := Bool(true)
 
     genRegDescsJson(mapping:_*)
-    genOMRegMap(mapping:_*)
-  }
-
-  def genOMRegMap(mapping: RegField.Map*): OMRegisterMap = {
-    OMRegister.convert(mapping = mapping:_*)
   }
 
   def genRegDescsJson(mapping: RegField.Map*): Unit = {
diff --git a/src/main/scala/tilelink/SRAM.scala b/src/main/scala/tilelink/SRAM.scala
index 5ebd9747eb2..46457372709 100644
--- a/src/main/scala/tilelink/SRAM.scala
+++ b/src/main/scala/tilelink/SRAM.scala
@@ -6,8 +6,6 @@ import chisel3._
 import chisel3.util._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.diplomaticobjectmodel.logicaltree.{BusMemoryLogicalTreeNode, LogicalModuleTree, LogicalTreeNode}
-import freechips.rocketchip.diplomaticobjectmodel.model.{OMECC, TL_UL}
 import freechips.rocketchip.util._
 import freechips.rocketchip.util.property
 
@@ -18,7 +16,6 @@ class TLRAMErrors(val params: ECCParams, val addrBits: Int) extends Bundle with
 
 class TLRAM(
     address: AddressSet,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     cacheable: Boolean = true,
     executable: Boolean = true,
     atomics: Boolean = false,
@@ -60,7 +57,7 @@ class TLRAM(
     val indexBits = (outer.address.mask & ~(beatBytes-1)).bitCount
     val width = code.width(eccBytes*8)
     val lanes = beatBytes/eccBytes
-    val (mem, omSRAM, omMem) = makeSinglePortedByteWriteSeqMem(
+    val mem = makeSinglePortedByteWriteSeqMem(
       size = BigInt(1) << indexBits,
       lanes = lanes,
       bits = width)
@@ -68,18 +65,6 @@ class TLRAM(
     val address = outer.address
     val laneDataBits = eccBytes * 8
 
-    parentLogicalTreeNode.map {
-      case parentLTN =>
-        def sramLogicalTreeNode = new BusMemoryLogicalTreeNode(
-          device = device,
-          omSRAMs = Seq(omSRAM),
-          busProtocol = new TL_UL(None),
-          dataECC = Some(OMECC.fromCode(ecc.code)),
-          hasAtomics = Some(atomics),
-          busProtocolSpecification = None)
-        LogicalModuleTree.add(parentLTN, sramLogicalTreeNode)
-    }
-
     /* This block has a three-stage pipeline
      * Stage A is the combinational request from TileLink A channel
      * Stage R corresponds to an accepted request
@@ -332,7 +317,6 @@ object TLRAM
 {
   def apply(
     address: AddressSet,
-    parentLogicalTreeNode: Option[LogicalTreeNode] = None,
     cacheable: Boolean = true,
     executable: Boolean = true,
     atomics: Boolean = false,
@@ -342,7 +326,7 @@ object TLRAM
     devName: Option[String] = None,
   )(implicit p: Parameters): TLInwardNode =
   {
-    val ram = LazyModule(new TLRAM(address, parentLogicalTreeNode, cacheable, executable, atomics, beatBytes, ecc, sramReg, devName))
+    val ram = LazyModule(new TLRAM(address, cacheable, executable, atomics, beatBytes, ecc, sramReg, devName))
     ram.node
   }
 }
diff --git a/src/main/scala/util/DescribedSRAM.scala b/src/main/scala/util/DescribedSRAM.scala
index 5ce1034356f..2484a56b278 100644
--- a/src/main/scala/util/DescribedSRAM.scala
+++ b/src/main/scala/util/DescribedSRAM.scala
@@ -5,8 +5,6 @@ package freechips.rocketchip.util
 
 import chisel3.{Data, SyncReadMem, Vec}
 import chisel3.util.log2Ceil
-import freechips.rocketchip.diplomaticobjectmodel.DiplomaticObjectModelAddressing
-import freechips.rocketchip.diplomaticobjectmodel.model.{OMSRAM, OMRTLModule}
 
 object DescribedSRAM {
   def apply[T <: Data](
@@ -14,7 +12,7 @@ object DescribedSRAM {
     desc: String,
     size: BigInt, // depth
     data: T
-  ): (SyncReadMem[T], OMSRAM) = {
+  ): SyncReadMem[T] = {
 
     val mem = SyncReadMem(size, data)
 
@@ -27,15 +25,6 @@ object DescribedSRAM {
 
     val uid = 0
 
-    val omSRAM = DiplomaticObjectModelAddressing.makeOMSRAM(
-      desc = desc,
-      width = data.getWidth,
-      depth = size,
-      granWidth = granWidth,
-      uid = uid,
-      rtlModule = OMRTLModule(moduleName=name)
-    )
-
     Annotated.srams(
       component = mem,
       name = name,
@@ -46,6 +35,6 @@ object DescribedSRAM {
       write_mask_granularity = granWidth
     )
 
-    (mem, omSRAM)
+    mem
   }
 }
