From 934aa2dfbb19c5344e9258dd95bcc9920cea8c2f Mon Sep 17 00:00:00 2001
From: Jiuyang Liu <liu@jiuyang.me>
Date: Wed, 1 Dec 2021 21:56:22 +0800
Subject: [PATCH] remove legacy tests which has been broken by Chisel/FIRRTL
 x.5.

---
 src/main/scala/dsptools/Driver.scala          |  93 -----
 .../DspRealFirrtlInterpBB.scala               | 374 -----------------
 .../numbers/chisel_concrete/DspReal.scala     |   7 +-
 .../tester/Chisel3TestersCompatibility.scala  |  33 --
 .../scala/dsptools/tester/DspTester.scala     | 394 ------------------
 .../dsptools/tester/DspTesterOptions.scala    | 126 ------
 .../dsptools/tester/DspTesterUtilities.scala  | 131 ------
 .../dsptools/tester/MemMasterModel.scala      |  11 -
 .../scala/dsptools/tester/VerilogTbDump.scala | 146 -------
 9 files changed, 4 insertions(+), 1311 deletions(-)
 delete mode 100644 src/main/scala/dsptools/Driver.scala
 delete mode 100644 src/main/scala/dsptools/numbers/blackbox_compatibility/DspRealFirrtlInterpBB.scala
 delete mode 100644 src/main/scala/dsptools/tester/Chisel3TestersCompatibility.scala
 delete mode 100644 src/main/scala/dsptools/tester/DspTester.scala
 delete mode 100644 src/main/scala/dsptools/tester/DspTesterOptions.scala
 delete mode 100644 src/main/scala/dsptools/tester/DspTesterUtilities.scala
 delete mode 100644 src/main/scala/dsptools/tester/MemMasterModel.scala
 delete mode 100644 src/main/scala/dsptools/tester/VerilogTbDump.scala

diff --git a/src/main/scala/dsptools/Driver.scala b/src/main/scala/dsptools/Driver.scala
deleted file mode 100644
index e776362e..00000000
--- a/src/main/scala/dsptools/Driver.scala
+++ /dev/null
@@ -1,93 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools
-
-import chisel3._
-import chisel3.iotesters.DriverCompatibility.ChiselExecutionResult
-import chisel3.iotesters._
-import firrtl.HasFirrtlOptions
-import numbers.{DspRealFactory, TreadleDspRealFactory}
-import firrtl_interpreter._
-
-import scala.util.DynamicVariable
-
-object Driver {
-
-  private val optionsManagerVar = new DynamicVariable[Option[DspTesterOptionsManager]](None)
-  def optionsManager = optionsManagerVar.value.getOrElse(new DspTesterOptionsManager)
-
-  def execute[T <: MultiIOModule](dutGenerator: () => T,
-      optionsManager: TesterOptionsManager)(testerGen: T => PeekPokeTester[T]): Boolean = {
-
-    val om = optionsManager match {
-      case d: DspTesterOptionsManager => Some(d)
-      case _ => None
-    }
-
-    optionsManagerVar.withValue(om) {
-      optionsManager.interpreterOptions = optionsManager.interpreterOptions.copy(
-          blackBoxFactories = optionsManager.interpreterOptions.blackBoxFactories :+ new DspRealFactory
-      )
-      optionsManager.treadleOptions = optionsManager.treadleOptions.copy(
-        blackBoxFactories = optionsManager.treadleOptions.blackBoxFactories :+ new TreadleDspRealFactory
-      )
-      iotesters.Driver.execute(dutGenerator, optionsManager)(testerGen)
-    }
-
-  }
-
-  def execute[T <: MultiIOModule](dutGenerator: () => T,
-      args: Array[String] = Array.empty)(testerGen: T => PeekPokeTester[T]): Boolean = {
-
-    val optionsManager = new DspTesterOptionsManager {
-      interpreterOptions = interpreterOptions.copy(
-          blackBoxFactories = interpreterOptions.blackBoxFactories :+ new DspRealFactory
-      )
-      treadleOptions = treadleOptions.copy(
-        blackBoxFactories = treadleOptions.blackBoxFactories :+ new TreadleDspRealFactory
-      )
-    }
-
-    if (optionsManager.parse(args)) {
-      execute(dutGenerator, optionsManager)(testerGen)
-    } else {
-      optionsManager.parser.showUsageAsError()
-      false
-    }
-  }
-
-  def executeFirrtlRepl[T <: MultiIOModule](dutGenerator: () => T,
-      optionsManager: ReplOptionsManager = new ReplOptionsManager): Boolean = {
-
-    optionsManager.chiselOptions = optionsManager.chiselOptions.copy(runFirrtlCompiler = false)
-    optionsManager.firrtlOptions = optionsManager.firrtlOptions.copy(compilerName = "low")
-    optionsManager.interpreterOptions = optionsManager.interpreterOptions.copy(
-        blackBoxFactories = optionsManager.interpreterOptions.blackBoxFactories :+ new DspRealFactory
-    )
-    optionsManager.treadleOptions = optionsManager.treadleOptions.copy(
-      blackBoxFactories = optionsManager.treadleOptions.blackBoxFactories :+ new TreadleDspRealFactory
-    )
-
-    logger.Logger.makeScope(optionsManager) {
-      val chiselResult: ChiselExecutionResult = iotesters.DriverCompatibility.execute(optionsManager, dutGenerator)
-      chiselResult match {
-        case iotesters.DriverCompatibility.ChiselExecutionSuccess(_, emitted, _) =>
-          optionsManager.replConfig = ReplConfig(firrtlSource = emitted)
-          FirrtlRepl.execute(optionsManager)
-          true
-        case iotesters.DriverCompatibility.ChiselExecutionFailure(message) =>
-          println("Failed to compile circuit")
-          false
-      }
-    }
-  }
-
-}
-
-class ReplOptionsManager
-  extends InterpreterOptionsManager
-    with HasInterpreterOptions
-    with HasChiselExecutionOptions
-    with HasFirrtlOptions
-    with HasReplConfig
-    with HasTreadleOptions
diff --git a/src/main/scala/dsptools/numbers/blackbox_compatibility/DspRealFirrtlInterpBB.scala b/src/main/scala/dsptools/numbers/blackbox_compatibility/DspRealFirrtlInterpBB.scala
deleted file mode 100644
index 3a0fcee0..00000000
--- a/src/main/scala/dsptools/numbers/blackbox_compatibility/DspRealFirrtlInterpBB.scala
+++ /dev/null
@@ -1,374 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools.numbers
-
-import firrtl.ir.Type
-import firrtl_interpreter._
-import treadle.{ScalaBlackBox, ScalaBlackBoxFactory}
-
-trait DspBlackBlackBoxImpl extends BlackBoxImplementation with ScalaBlackBox
-
-abstract class DspRealTwoArgumentToDouble extends DspBlackBlackBoxImpl {
-  /**
-    * sub-classes must implement this two argument function
-    *
-    * @param double1 first operand
-    * @param double2 second operand
-    * @return        double operation result
-    */
-  def twoOp(double1: Double, double2: Double): Double
-
-  def outputDependencies(outputName: String): Seq[(String)] = {
-    outputName match {
-      case "out" => Seq("in1", "in2")
-      case _ => Seq.empty
-    }
-  }
-
-  override def getOutput(inputValues: Seq[BigInt], tpe: Type, outputName: String): BigInt = {
-    val arg1 :: arg2 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1)
-    val doubleArg2 = bigIntBitsToDouble(arg2)
-    val doubleResult = twoOp(doubleArg1, doubleArg2)
-    doubleToBigIntBits(doubleResult)
-  }
-
-  def cycle(): Unit = {}
-
-  def execute(inputValues: Seq[Concrete], tpe: Type, outputName: String): Concrete = {
-    val arg1 :: arg2 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1.value)
-    val doubleArg2 = bigIntBitsToDouble(arg2.value)
-    val doubleResult = twoOp(doubleArg1, doubleArg2)
-    val result = doubleToBigIntBits(doubleResult)
-    ConcreteSInt(result, DspReal.underlyingWidth, arg1.poisoned || arg2.poisoned).asUInt
-  }
-}
-
-abstract class DspRealOneArgumentToDouble extends DspBlackBlackBoxImpl {
-  /**
-    * sub-classes must implement this two argument function
-    *
-    * @param double1 first operand
-    * @return        double operation result
-    */
-  def oneOp(double1: Double): Double
-
-  def outputDependencies(outputName: String): Seq[(String)] = {
-    outputName match {
-      case "out" => Seq("in")
-      case _ => Seq.empty
-    }
-  }
-  def cycle(): Unit = {}
-
-  def execute(inputValues: Seq[Concrete], tpe: Type, outputName: String): Concrete = {
-    val arg1 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1.value)
-    val doubleResult = oneOp(doubleArg1)
-    val result = doubleToBigIntBits(doubleResult)
-    ConcreteSInt(result, DspReal.underlyingWidth, arg1.poisoned).asUInt
-  }
-
-  def getOutput(inputValues: Seq[BigInt], tpe: Type, outputName: String): BigInt = {
-    val arg1 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1)
-    val doubleResult = oneOp(doubleArg1)
-    doubleToBigIntBits(doubleResult)
-  }
-}
-
-abstract class DspRealTwoArgumentToBoolean extends DspBlackBlackBoxImpl {
-  /**
-    * sub-classes must implement this two argument function
-    *
-    * @param double1 first operand
-    * @param double2 second operand
-    * @return        boolean operation result
-    */
-  def twoOp(double1: Double, double2: Double): Boolean
-
-  def outputDependencies(outputName: String): Seq[(String)] = {
-    outputName match {
-      case "out" => Seq("in1", "in2")
-      case _ => Seq.empty
-    }
-  }
-  def cycle(): Unit = {}
-
-  def getOutput(inputValues: Seq[BigInt], tpe: Type, outputName: String): BigInt = {
-    val arg1 :: arg2 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1)
-    val doubleArg2 = bigIntBitsToDouble(arg2)
-    val booleanResult = twoOp(doubleArg1, doubleArg2)
-    if (booleanResult) Big1 else Big0
-  }
-
-  def execute(inputValues: Seq[Concrete], tpe: Type, outputName: String): Concrete = {
-    val arg1 :: arg2 :: _ = inputValues
-    val doubleArg1 = bigIntBitsToDouble(arg1.value)
-    val doubleArg2 = bigIntBitsToDouble(arg2.value)
-    val booleanResult = twoOp(doubleArg1, doubleArg2)
-    val result = if (booleanResult) Big1 else Big0
-    TypeInstanceFactory(tpe, result, arg1.poisoned || arg2.poisoned)
-  }
-}
-
-class DspRealAdd(val name: String) extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = double1 + double2
-}
-
-class DspRealSubtract(val name: String) extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = double1 - double2
-}
-
-class DspRealMultiply(val name: String) extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = double1 * double2
-}
-
-class DspRealDivide(val name: String) extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = double1 / double2
-}
-
-class DspRealGreaterThan(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 > double2
-}
-
-class DspRealGreaterThanEquals(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 >= double2
-}
-
-class DspRealLessThan(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 < double2
-}
-
-class DspRealLessThanEquals(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 <= double2
-}
-
-class DspRealEquals(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 == double2
-}
-
-class DspRealNotEquals(val name: String) extends DspRealTwoArgumentToBoolean {
-  def twoOp(double1: Double, double2: Double): Boolean = double1 != double2
-}
-
-// Angie: Let's rely on type classes to get this behavior instead
-/*
-class DspRealIntPart(val name: String) extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = double1.toInt.toDouble
-}
-*/
-
-/** Math operations from IEEE.1364-2005 **/
-class DspRealLn(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.log(double1)
-}
-
-class DspRealLog10(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.log10(double1)
-}
-
-class DspRealExp(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.exp(double1)
-}
-
-class DspRealSqrt(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.sqrt(double1)
-}
-
-class DspRealPow(val name: String)  extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = math.pow(double1, double2)
-}
-
-class DspRealFloor(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.floor(double1)
-}
-
-class DspRealCeil(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.ceil(double1)
-}
-
-class DspRealSin(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.sin(double1)
-}
-
-class DspRealCos(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.cos(double1)
-}
-
-class DspRealTan(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.tan(double1)
-}
-
-class DspRealASin(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.asin(double1)
-}
-
-class DspRealACos(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.acos(double1)
-}
-
-class DspRealATan(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.atan(double1)
-}
-
-class DspRealATan2(val name: String)  extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = math.atan2(double1, double2)
-}
-
-class DspRealHypot(val name: String)  extends DspRealTwoArgumentToDouble {
-  def twoOp(double1: Double, double2: Double): Double = math.hypot(double1, double2)
-}
-
-class DspRealSinh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.sinh(double1)
-}
-
-class DspRealCosh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.cosh(double1)
-}
-
-class DspRealTanh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.tanh(double1)
-}
-
-class DspRealASinh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.log(double1 + math.sqrt(double1 * double1 + 1))
-}
-
-class DspRealACosh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = math.log(double1 + math.sqrt(double1 * double1 - 1))
-}
-
-class DspRealATanh(val name: String)  extends DspRealOneArgumentToDouble {
-  def oneOp(double1: Double): Double = 0.5 * math.log((1 + double1) / (1 - double1))
-}
-
-class DspRealToInt(val name: String) extends DspBlackBlackBoxImpl {
-  def outputDependencies(outputName: String): Seq[(String)] = {
-    outputName match {
-      case "out" => Seq("in")
-      case _ => Seq.empty
-    }
-  }
-  def cycle(): Unit = {}
-
-  def execute(inputValues: Seq[Concrete], tpe: Type, outputName: String): Concrete = {
-    val arg1 :: _ = inputValues
-    val result = arg1.value
-    TypeInstanceFactory(tpe, result)
-  }
-
-  def getOutput(inputValues: Seq[BigInt], tpe: Type, outputName: String): BigInt = {
-    val arg1 :: _ = inputValues
-    arg1
-  }
-}
-
-class DspRealFromInt(val name: String) extends DspBlackBlackBoxImpl {
-  def outputDependencies(outputName: String): Seq[(String)] = {
-    outputName match {
-      case "out" => Seq("in")
-      case _ => Seq.empty
-    }
-  }
-  def cycle(): Unit = {}
-
-  def getOutput(inputValues: Seq[BigInt], tpe: Type, outputName: String): BigInt = {
-    val arg1 :: _ = inputValues
-    arg1
-  }
-
-  def execute(inputValues: Seq[Concrete], tpe: Type, outputName: String): Concrete = {
-    val arg1 :: _ = inputValues
-    val result = arg1.value
-    TypeInstanceFactory(tpe, result)
-  }
-}
-
-//scalastyle:off cyclomatic.complexity
-class DspRealFactory extends BlackBoxFactory {
-  def createInstance(instanceName: String, blackBoxName: String): Option[BlackBoxImplementation] = {
-    blackBoxName match {
-      case "BBFAdd"               => Some(add(new DspRealAdd(instanceName)))
-      case "BBFSubtract"          => Some(add(new DspRealSubtract(instanceName)))
-      case "BBFMultiply"          => Some(add(new DspRealMultiply(instanceName)))
-      case "BBFDivide"            => Some(add(new DspRealDivide(instanceName)))
-      case "BBFLessThan"          => Some(add(new DspRealLessThan(instanceName)))
-      case "BBFLessThanEquals"    => Some(add(new DspRealLessThanEquals(instanceName)))
-      case "BBFGreaterThan"       => Some(add(new DspRealGreaterThan(instanceName)))
-      case "BBFGreaterThanEquals" => Some(add(new DspRealGreaterThanEquals(instanceName)))
-      case "BBFEquals"            => Some(add(new DspRealEquals(instanceName)))
-      case "BBFNotEquals"         => Some(add(new DspRealNotEquals(instanceName)))
-      case "BBFFromInt"           => Some(add(new DspRealFromInt(instanceName)))
-      case "BBFToInt"             => Some(add(new DspRealToInt(instanceName)))
-      //case "BBFIntPart"           => Some(add(new DspRealIntPart(instanceName)))
-      case "BBFLn"                => Some(add(new DspRealLn(instanceName)))
-      case "BBFLog10"             => Some(add(new DspRealLog10(instanceName)))
-      case "BBFExp"               => Some(add(new DspRealExp(instanceName)))
-      case "BBFSqrt"              => Some(add(new DspRealSqrt(instanceName)))
-      case "BBFPow"               => Some(add(new DspRealPow(instanceName)))
-      case "BBFFloor"             => Some(add(new DspRealFloor(instanceName)))
-      case "BBFCeil"              => Some(add(new DspRealCeil(instanceName)))
-      case "BBFSin"               => Some(add(new DspRealSin(instanceName)))
-      case "BBFCos"               => Some(add(new DspRealCos(instanceName)))
-      case "BBFTan"               => Some(add(new DspRealTan(instanceName)))
-      case "BBFASin"              => Some(add(new DspRealASin(instanceName)))
-      case "BBFACos"              => Some(add(new DspRealACos(instanceName)))
-      case "BBFATan"              => Some(add(new DspRealATan(instanceName)))
-      case "BBFATan2"             => Some(add(new DspRealATan2(instanceName)))
-      case "BBFHypot"             => Some(add(new DspRealHypot(instanceName)))
-      case "BBFSinh"              => Some(add(new DspRealSinh(instanceName)))
-      case "BBFCosh"              => Some(add(new DspRealCosh(instanceName)))
-      case "BBFTanh"              => Some(add(new DspRealTanh(instanceName)))
-      case "BBFASinh"             => Some(add(new DspRealASinh(instanceName)))
-      case "BBFACosh"             => Some(add(new DspRealACosh(instanceName)))
-      case "BBFATanh"             => Some(add(new DspRealATanh(instanceName)))
-      case _                      => None
-    }
-  }
-}
-
-class TreadleDspRealFactory extends ScalaBlackBoxFactory {
-  def createInstance(instanceName: String, blackBoxName: String): Option[ScalaBlackBox] = {
-    blackBoxName match {
-      case "BBFAdd"               => Some(add(new DspRealAdd(instanceName)))
-      case "BBFSubtract"          => Some(add(new DspRealSubtract(instanceName)))
-      case "BBFMultiply"          => Some(add(new DspRealMultiply(instanceName)))
-      case "BBFDivide"            => Some(add(new DspRealDivide(instanceName)))
-      case "BBFLessThan"          => Some(add(new DspRealLessThan(instanceName)))
-      case "BBFLessThanEquals"    => Some(add(new DspRealLessThanEquals(instanceName)))
-      case "BBFGreaterThan"       => Some(add(new DspRealGreaterThan(instanceName)))
-      case "BBFGreaterThanEquals" => Some(add(new DspRealGreaterThanEquals(instanceName)))
-      case "BBFEquals"            => Some(add(new DspRealEquals(instanceName)))
-      case "BBFNotEquals"         => Some(add(new DspRealNotEquals(instanceName)))
-      case "BBFFromInt"           => Some(add(new DspRealFromInt(instanceName)))
-      case "BBFToInt"             => Some(add(new DspRealToInt(instanceName)))
-      //case "BBFIntPart"           => Some(add(new DspRealIntPart(instanceName)))
-      case "BBFLn"                => Some(add(new DspRealLn(instanceName)))
-      case "BBFLog10"             => Some(add(new DspRealLog10(instanceName)))
-      case "BBFExp"               => Some(add(new DspRealExp(instanceName)))
-      case "BBFSqrt"              => Some(add(new DspRealSqrt(instanceName)))
-      case "BBFPow"               => Some(add(new DspRealPow(instanceName)))
-      case "BBFFloor"             => Some(add(new DspRealFloor(instanceName)))
-      case "BBFCeil"              => Some(add(new DspRealCeil(instanceName)))
-      case "BBFSin"               => Some(add(new DspRealSin(instanceName)))
-      case "BBFCos"               => Some(add(new DspRealCos(instanceName)))
-      case "BBFTan"               => Some(add(new DspRealTan(instanceName)))
-      case "BBFASin"              => Some(add(new DspRealASin(instanceName)))
-      case "BBFACos"              => Some(add(new DspRealACos(instanceName)))
-      case "BBFATan"              => Some(add(new DspRealATan(instanceName)))
-      case "BBFATan2"             => Some(add(new DspRealATan2(instanceName)))
-      case "BBFHypot"             => Some(add(new DspRealHypot(instanceName)))
-      case "BBFSinh"              => Some(add(new DspRealSinh(instanceName)))
-      case "BBFCosh"              => Some(add(new DspRealCosh(instanceName)))
-      case "BBFTanh"              => Some(add(new DspRealTanh(instanceName)))
-      case "BBFASinh"             => Some(add(new DspRealASinh(instanceName)))
-      case "BBFACosh"             => Some(add(new DspRealACosh(instanceName)))
-      case "BBFATanh"             => Some(add(new DspRealATanh(instanceName)))
-      case _                      => None
-    }
-  }
-}
diff --git a/src/main/scala/dsptools/numbers/chisel_concrete/DspReal.scala b/src/main/scala/dsptools/numbers/chisel_concrete/DspReal.scala
index e6ea13b4..5c8f042b 100644
--- a/src/main/scala/dsptools/numbers/chisel_concrete/DspReal.scala
+++ b/src/main/scala/dsptools/numbers/chisel_concrete/DspReal.scala
@@ -116,9 +116,10 @@ class DspReal(val lit: Option[BigInt] = None) extends Bundle {
   def abs(): DspReal = Mux(this < DspReal(0.0), DspReal(0.0) - this, this)
 
   // Assumes you're using chisel testers
-  private def backendIsVerilator: Boolean = {
-    chisel3.iotesters.Driver.optionsManager.testerOptions.backendName == "verilator"
-  }
+  private def backendIsVerilator: Boolean = true
+//  {
+//    chisel3.iotesters.Driver.optionsManager.testerOptions.backendName == "verilator"
+//  }
 
   // The following are currently not supported with Verilator, so they've been implemented through other means
   // with approximately 6 decimal points of precision
diff --git a/src/main/scala/dsptools/tester/Chisel3TestersCompatibility.scala b/src/main/scala/dsptools/tester/Chisel3TestersCompatibility.scala
deleted file mode 100644
index a56947a0..00000000
--- a/src/main/scala/dsptools/tester/Chisel3TestersCompatibility.scala
+++ /dev/null
@@ -1,33 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package chisel3.iotesters
-
-import chisel3._
-import chisel3.experimental.DataMirror
-
-// Bring out a bunch of private functions
-object TestersCompatibility {
-
-  // Stolen from chisel-testers hack
-  private def extractElementBits(signal: Data): IndexedSeq[Element] = {
-    signal match {
-      case elt: Aggregate => elt.getElements.toIndexedSeq flatMap {extractElementBits(_)}
-      case elt: Element => IndexedSeq(elt)
-      case elt => throw new Exception(s"Cannot extractElementBits for type ${elt.getClass}")
-    }
-  }
-
-  def flatten[T <: Aggregate](d: T): IndexedSeq[Bits] = extractElementBits(d) map { x => x.asInstanceOf[Bits]}
-
-  def getModuleNames(mod: RawModule): Seq[(Element, String)] = {
-    DataMirror.modulePorts(mod).flatMap(p => getDataNames(p._1, p._2))
-  }
-  def getDataNames(name: String, data: Data): Seq[(Element, String)] = {
-    chisel3.iotesters.getDataNames(name, data)
-  }
-  def validName(name: String): String = chisel3.iotesters.validName(name)
-  def bigIntToStr(x: BigInt, base: Int): String = chisel3.iotesters.bigIntToStr(x, base)
-}
-
-
-
diff --git a/src/main/scala/dsptools/tester/DspTester.scala b/src/main/scala/dsptools/tester/DspTester.scala
deleted file mode 100644
index faee1d4f..00000000
--- a/src/main/scala/dsptools/tester/DspTester.scala
+++ /dev/null
@@ -1,394 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools
-
-import breeze.math.Complex
-import chisel3._
-import chisel3.experimental.{FixedPoint, Interval}
-import chisel3.internal.firrtl.KnownBinaryPoint
-import chisel3.iotesters.{PeekPokeTester, Pokeable}
-import dsptools.DspTesterUtilities._
-import dsptools.numbers.{DspComplex, DspReal}
-
-import scala.util.DynamicVariable
-
-// TODO: Get rid of
-import chisel3.iotesters.TestersCompatibility
-
-//scalastyle:off number.of.methods cyclomatic.complexity
-class DspTester[+T <: MultiIOModule](
-    dut: T,
-    base: Int = 16,
-    logFile: Option[java.io.File] = None) extends PeekPokeTester(dut, base, logFile) with VerilogTbDump {
-
-  // Changes displayed base of standard PeekPokeTester info text
-  // Note: base is not relevant to Doubles
-  val updatableBase = new DynamicVariable[Int](_base)
-  private def dispBase = updatableBase.value
-
-  // Verbosity @ highest DSP level (different from chisel-testers verbosity = standard peek/poke)
-  val updatableDspVerbose = new DynamicVariable[Boolean](dsptestersOpt.isVerbose)
-  private def dispDsp = updatableDspVerbose.value
-
-  // Verbosity @ normal peek/poke level (chisel-testers verbosity) -- for additionally displaying as bits
-  // and also all sub levels of abstraction i.e. expect relies on peek, but peek string won't be printed
-  // if dispSub = false
-  val updatableSubVerbose = new DynamicVariable[Boolean](iotestersOM.testerOptions.isVerbose)
-  private def dispSub = updatableSubVerbose.value
-
-  // UInt, SInt, FixedPoint, Interval tolerance in LSBs
-  val fixTolLSBs = new DynamicVariable[Int](dsptestersOpt.fixTolLSBs)
-  private def fixTol = fixTolLSBs.value
-
-  // DspReal tolerance in decimal point precision
-  val realTolDecPts = new DynamicVariable[Int](dsptestersOpt.realTolDecPts)
-  private def realTol = realTolDecPts.value
-
-  // Tester starts with reset (but don't count cycles during reset)
-  //scalastyle:off magic.number
-  super.reset(5)
-
-  ///////////////// OVERRIDE UNDERLYING FUNCTIONS FROM PEEK POKE TESTER /////////////////
-
-  override def step(n: Int) {
-    if (dispDsp) logger info s"STEP ${n}x -> ${t + n}"
-    stepPrint(n)
-    backend.step(n)
-    incTime(n)
-  }
-
-  override def reset(n: Int = 1) {
-    if (dispDsp) logger info s"RESET ${n}x -> ${t + n}"
-    resetPrint(n)
-    backend.reset(n)
-    incTime(n)
-  }
-
-  private def maskedBigInt(bigInt: BigInt, width: Int): BigInt = {
-    val maskedBigInt = bigInt & ((BigInt(1) << width) - 1)
-    maskedBigInt
-  }
-
-  override def poke(path: String, value: BigInt): Unit = {
-    if (verilogTb) throw DspException("Don't use poke path (String) when printing verilog tb")
-    backend.poke(path, value)(logger, dispDsp, dispBase)
-  }
-
-  override def poke[T <: Element : Pokeable](signal: T, value: BigInt): Unit = {
-    // bit-level poke is displayed as unsigned
-    val maskedValue = maskedBigInt(value, signal.widthOption.getOrElse(128))
-    validRangeTest(signal, value)
-    if (!signal.isLit) backend.poke(signal, maskedValue, None)(logger, dispDsp, dispBase)
-    pokePrint(signal, value)
-  }
-
-  // Poke at does not involve external signals -- no VerilogTB print
-  override def pokeAt[TT <: Element : Pokeable](data: MemBase[TT], value: BigInt, off: Int): Unit = {
-    backend.poke(data, value, Some(off))(logger, dispDsp, dispBase)
-  }
-
-  override def peek(path: String): BigInt = {
-    if (verilogTb) throw DspException("Don't use peek path (String) when printing verilog tb")
-    backend.peek(path)(logger, dispDsp, dispBase)
-  }
-
-  override def peek[T <: Element : Pokeable](signal: T): BigInt = {
-    val o = {
-      // bit-level peek is displayed as unsigned
-      if (!signal.isLit) {
-        backend.peek(signal, None)(logger, dispDsp, dispBase)
-      } else {
-        val litVal = signal.litValue()
-        if (dispDsp) {
-          logger info s"  PEEK ${getName(signal)} -> ${TestersCompatibility.bigIntToStr(litVal, dispBase)}"
-        }
-        litVal
-      }
-    }
-    peekPrint(signal, o)
-    o
-  }
-
-  override def peek(signal: Aggregate): IndexedSeq[BigInt] =  {
-    // Flatten returns IndexSeq[BigInt], so will use above peek
-    TestersCompatibility.flatten(signal) map { x => peek(x) }
-  }
-
-  // Peek at does not involve external signals -- no VerilogTB print
-  override def peekAt[TT <: Element : Pokeable](data: MemBase[TT], off: Int): BigInt = {
-    backend.peek(data, Some(off))(logger, dispDsp, dispBase)
-  }
-
-  override def expect(good: Boolean, msg: => String): Boolean = {
-    if (dispDsp || !good) logger info ( { if (!good) Console.RED else "" } +
-      s"EXPECT AT $t $msg ${if (good) "PASS" else "FAIL"}" + Console.RESET)
-    if (!good) fail
-    good
-  }
-
-  def expect(signal: Bits, expected: BigInt): Boolean = expect(signal, expected, "")
-  override def expect[T <: Element : Pokeable](signal: T, expected: BigInt, msg: => String): Boolean = {
-    validRangeTest(signal, expected)
-    val path = getName(signal)
-    val got = updatableDspVerbose.withValue(dispSub) { peek(signal) }
-    val good = got == expected
-    if (dispDsp || !good) logger info ( { if (!good) Console.RED else "" } +
-      s"$msg  EXPECT $path -> ${TestersCompatibility.bigIntToStr(got, dispBase)} == E " +
-        s"${TestersCompatibility.bigIntToStr(expected, dispBase)} ${if (good) "PASS" else "FAIL"}" + Console.RESET)
-    if (!good) fail
-    good
-  }
-
-  override def finish: Boolean = {
-    finishVerilogTb()
-    super.finish
-  }
-
-  ///////////////// UNDERLYING FUNCTIONS FROM DSP TESTER /////////////////
-
-  def poke(signal: Bool, value: Boolean): Unit = poke(signal, if (value) BigInt(1) else BigInt(0))
-
-  // Need to specify what happens when you poke with an Int
-  // Display as Double (so you can separate out number representation vs. bit representation)
-  def poke(signal: UInt, value: Int): Unit = poke(signal.asInstanceOf[Data], value.toDouble)
-  def poke(signal: SInt, value: Int): Unit = poke(signal.asInstanceOf[Data], value.toDouble)
-
-  // Has priority over Bits (FixedPoint extends Bits)
-  def poke(signal: FixedPoint, value: Int): Unit = poke(signal, value.toDouble)
-  def poke(signal: FixedPoint, value: Double): Unit = poke(signal.asInstanceOf[Data], value)
-
-  // Has priority over Bits (Interval extends Bits)
-  def poke(signal: Interval, value: Int): Unit = poke(signal, value.toDouble)
-  def poke(signal: Interval, value: Double): Unit = poke(signal.asInstanceOf[Data], value)
-  def poke(signal: Interval, value: BigDecimal): Unit = {
-    assert(value <= Double.MaxValue, s"poking ${signal} with a value $value bigger than Double.MaxValue")
-    poke(signal.asInstanceOf[Data], value.toDouble)
-  }
-
-  // DspReal extends Bundle extends Aggregate extends Data
-  // If poking DspReal with Double, can only go here
-  // Type classes are all Data:RealBits
-  //scalastyle:off cyclomatic.complexity
-  def poke(signal: Data, value: Double): Unit = {
-    updatableDspVerbose.withValue(dispSub) {
-      signal match {
-        case i: Interval =>
-          i.binaryPoint match {
-            case KnownBinaryPoint(bp) => poke(i.asInstanceOf[Bits], Interval.toBigInt(value, bp))
-            case _ => throw DspException("Must poke Interval with known binary point")
-          }
-        case f: FixedPoint =>
-          f.binaryPoint match {
-            case KnownBinaryPoint(bp) => poke(f.asInstanceOf[Bits], FixedPoint.toBigInt(value, bp))
-            case _ => throw DspException("Must poke FixedPoint with known binary point")
-          }
-        case r: DspReal => poke(r.node.asInstanceOf[Bits], DspTesterUtilities.doubleToBigIntBits(value))
-        // UInt + SInt
-        case b: Bits => poke(b.asInstanceOf[Bits], BigInt(value.round.toInt))
-        case _ => throw DspException("Illegal poke value for node of type Data and value of type Double")
-      }
-    }
-    if (dispDsp) logger info s"  POKE ${getName(signal)} <- $value, ${bitInfo(signal)}"
-  }
-  def poke(signal: Data, value: BigDecimal): Unit = {
-    assert(value <= Double.MaxValue, s"poking ${signal} with a value $value bigger than Double.MaxValue")
-    poke(signal, value.toDouble)
-  }
-
-  // Will only print individual real/imag peek information if dispSub is true!
-  def poke(c: DspComplex[_], value: Complex): Unit = {
-    updatableDspVerbose.withValue(dispSub) {
-      poke(c.real.asInstanceOf[Data], value.real)
-      poke(c.imag.asInstanceOf[Data], value.imag)
-    }
-    if (dispDsp) logger info s"  POKE ${getName(c)} <- ${value.toString}, ${bitInfo(c)}"
-  }
-
-  def dspPeekWithBigInt(node: Data): (Double, BigInt) = dspPeek(node)
-
-  private def dspPeek(node: Data): (Double, BigInt) = {
-    val bi: BigInt = updatableDspVerbose.withValue(dispSub) {
-      node match {
-        // Unsigned bigint
-        case r: DspReal => peek(r.node.asInstanceOf[Bits])
-        case b: Bits => peek(b.asInstanceOf[Bits])
-      }
-    }
-    val (dblOut, bigIntOut) = node match {
-      case _: DspReal => (DspTesterUtilities.bigIntBitsToDouble(bi), bi)
-      case i: Interval => i.binaryPoint match {
-        case KnownBinaryPoint(bp) => (Interval.toDouble(bi, bp), bi)
-        case _ => throw DspException("Cannot peek Interval with unknown binary point location")
-      }
-      case f: FixedPoint => f.binaryPoint match {
-        case KnownBinaryPoint(bp) => (FixedPoint.toDouble(bi, bp), bi)
-        case _ => throw DspException("Cannot peek FixedPoint with unknown binary point location")
-      }
-      // UInt + SInt = Bits
-      case _: Bits => (bi.doubleValue, bi)
-      case _ => throw DspException(s"Peeked node ${getName(node)} has incorrect type ${node.getClass.getName}")
-    }
-    if (dispDsp) logger info s"  PEEK ${getName(node)} -> $dblOut, ${bitInfo(node)}"
-    (dblOut, bigIntOut)
-  }
-
-  // Takes precedence over Bits
-  def peek(node: Bool): Boolean = {
-    if (peek(node.asInstanceOf[Bits]) == 1) true else false
-  }
-  def peek(node: UInt): Int = dspPeek(node)._1.round.toInt
-  def peek(node: SInt): Int = dspPeek(node)._1.round.toInt
-  def peek(node: FixedPoint): Double = dspPeek(node)._1
-  def peek(node: Interval): Double = dspPeek(node)._1
-  // Takes precedence over Aggregate
-  def peek(node: DspReal): Double = dspPeek(node)._1
-
-  // General type returns Double
-  def peek(node: Data): Double = dspPeek(node)._1
-
-  def peek(c: DspComplex[_]): Complex = {
-    val out = updatableDspVerbose.withValue(dispSub) {
-      Complex(dspPeek(c.real.asInstanceOf[Data])._1, dspPeek(c.imag.asInstanceOf[Data])._1)
-    }
-    if (dispDsp) logger info s"  PEEK ${getName(c)} <- ${out.toString}, ${bitInfo(c)}"
-    out
-  }
-
-  def expect(signal: Bool, expected: Boolean): Boolean = expect(signal, expected, "")
-  def expect(signal: Bool, expected: Boolean, msg: String): Boolean = {
-    expect(signal.asInstanceOf[Bits], if (expected) BigInt(1) else BigInt(0), msg)
-  }
-
-  // If expecting directly on UInt or SInt (rather than generic type class),
-  // set tolerance to be 0 bits (i.e. must match exactly)
-  def expect(signal: UInt, expected: Int): Boolean = expect(signal, expected, "")
-  def expect(signal: UInt, expected: Int, msg: String): Boolean = fixTolLSBs.withValue(0) {
-    expect(signal.asInstanceOf[Data], expected.toDouble, msg)
-  }
-  def expect(signal: SInt, expected: Int): Boolean = expect(signal, expected, "")
-  def expect(signal: SInt, expected: Int, msg: String): Boolean = fixTolLSBs.withValue(0) {
-    expect(signal.asInstanceOf[Data], expected.toDouble, msg)
-  }
-
-  // Priority over Bits
-  def expect(signal: FixedPoint, expected: Int): Boolean = expect(signal, expected, "")
-  def expect(signal: FixedPoint, expected: Int, msg: String): Boolean = expect(signal, expected.toDouble, msg)
-  def expect(signal: FixedPoint, expected: Double): Boolean = expect(signal, expected, "")
-  def expect(signal: FixedPoint, expected: Double, msg: String): Boolean = {
-    expect(signal.asInstanceOf[Data], expected, msg)
-  }
-
-  // Priority over Bits
-  def expect(signal: Interval, expected: Int): Boolean = expect(signal, expected, "")
-  def expect(signal: Interval, expected: Int, msg: String): Boolean = expect(signal, expected.toDouble, msg)
-  def expect(signal: Interval, expected: Double): Boolean = expect(signal, expected, "")
-  def expect(signal: Interval, expected: Double, msg: String): Boolean = {
-    expect(signal.asInstanceOf[Data], expected, msg)
-  }
-
-  ///////////////// SPECIALIZED DSP EXPECT /////////////////
-
-  //scalastyle:off cyclomatic.complexity
-  def checkDecimal(data: Data, expected: Double, dblVal: Double, bitVal: BigInt): (Boolean, Double) = {
-    def toMax(w: Int): BigInt = (BigInt(1) << w) - 1
-    // <=
-    val fixTolInt = toMax(fixTol)
-    val floTolDec = math.pow(10,-realTol)
-    // Error checking does a bad job of handling really small numbers,
-    // so let's just force the really small numbers to 0
-    val expected0 = if (math.abs(expected) < floTolDec/100) 0.0 else expected
-    val dblVal0 = if (math.abs(dblVal) < floTolDec/100) 0.0 else dblVal
-    val expectedBits = data match {
-      case _: DspReal => DspTesterUtilities.doubleToBigIntBits(expected0)     // unsigned BigInt
-      case i: Interval => i.binaryPoint match {
-        case KnownBinaryPoint(bp) => Interval.toBigInt(expected0, bp)
-        case _ => throw DspException("Unknown binary point in Interval on expect")
-      }
-      case f: FixedPoint => f.binaryPoint match {
-        case KnownBinaryPoint(bp) => FixedPoint.toBigInt(expected0, bp)
-        case _ => throw DspException("Unknown binary point in FixedPoint on expect")
-      }
-      case _: Bits => BigInt(expected0.round.toInt)
-    }
-
-    validRangeTest(data, expectedBits)
-
-    // Allow for some tolerance in error checking
-    val (tolerance, tolDec) = data match {
-      case i: Interval => i.binaryPoint match {
-        case KnownBinaryPoint(bp) => (fixTolInt, Interval.toDouble(fixTolInt, bp))
-        case _ => throw DspException("Unknown binary point!")
-      }
-      case f: FixedPoint => f.binaryPoint match {
-        case KnownBinaryPoint(bp) => (fixTolInt, FixedPoint.toDouble(fixTolInt, bp))
-        case _ => throw DspException("Unknown binary point!")
-      }
-      case _: SInt | _: UInt => (fixTolInt, fixTolInt.toDouble)
-      case _: DspReal => (DspTesterUtilities.doubleToBigIntBits(floTolDec), floTolDec)
-    }
-    val good = {
-      if (dblVal0 != expected0) {
-        val gotDiffDbl = math.abs(dblVal0-expected0)
-        val gotDiffBits = (bitVal - expectedBits).abs
-        val passDbl = gotDiffDbl <= tolDec
-        val passBits = gotDiffBits <= tolerance
-        passDbl && passBits
-      } else {
-        true
-      }
-    }
-    (good, tolDec)
-  }
-
-  // Expect on DspReal goes straight to here
-  def expect(data: Data, expected: Double): Boolean = expect(data, expected, msg = "")
-  def expectWithoutFailure(data: Data, expected: Double, msg: String = ""): Boolean = {
-    val expectedNew = roundData(data, expected)
-    val path = getName(data)
-    val (dblVal, bitVal) = updatableDspVerbose.withValue(dispSub) { dspPeek(data) }
-    val (good, tolerance) = checkDecimal(data, expectedNew, dblVal, bitVal)
-    if (dispDsp) logger info
-      (
-        s"$msg  EXPECT $path -> $dblVal == E " +
-        s"$expectedNew ${if (good) "PASS" else "FAIL"}, tolerance = $tolerance, ${bitInfo(data)}" +
-        Console.RESET
-      )
-    good
-  }
-  def expect(data: Data, expected: Double, msg: String): Boolean = {
-    val good = expectWithoutFailure(data, expected, msg)
-    if (!good) fail
-    good
-  }
-
-  def expect(data: Data, expected: BigDecimal): Boolean = expect(data, expected, "")
-  def expect(data: Data, expected: BigDecimal, msg: String): Boolean = {
-    assert(expected <= Double.MaxValue, s"expecting from ${data} a value $expected that is bigger than Double.MaxValue")
-    val good = expectWithoutFailure(data, expected.toDouble, msg)
-    if (!good) fail
-    good
-  }
-
-  def expect(data: DspComplex[_], expected: Complex): Boolean = expect(data, expected, msg = "")
-  def expect(data: DspComplex[_], expected: Complex, msg: String): Boolean = {
-    val dataReal = data.real.asInstanceOf[Data]
-    val dataImag = data.imag.asInstanceOf[Data]
-    val expectedNewR = roundData(dataReal, expected.real)
-    val expectedNewI = roundData(dataImag, expected.imag)
-    val path = getName(data)
-    val (good, dblValR, dblValI, toleranceR) = updatableDspVerbose.withValue(dispSub) {
-      val (dblValR, bitValR) = dspPeek(dataReal)
-      val (dblValI, bitValI) = dspPeek(dataImag)
-      val (goodR, toleranceR) = checkDecimal(dataReal, expectedNewR, dblValR, bitValR)
-      val (goodI, _) = checkDecimal(dataImag, expectedNewI, dblValI, bitValI)
-      (goodR & goodI, dblValR, dblValI, toleranceR)
-    }
-    if (dispDsp || !good) logger info ( { if (!good) Console.RED else "" } +
-      s"$msg  EXPECT $path -> $dblValR + $dblValI i == E " +
-      s"$expectedNewR + $expectedNewI i ${if (good) "PASS" else "FAIL"}, tolerance = $toleranceR, " +
-      s"${bitInfo(data)}" +
-      Console.RESET)
-    if (!good) fail
-    good
-  }
-}
diff --git a/src/main/scala/dsptools/tester/DspTesterOptions.scala b/src/main/scala/dsptools/tester/DspTesterOptions.scala
deleted file mode 100644
index 03885290..00000000
--- a/src/main/scala/dsptools/tester/DspTesterOptions.scala
+++ /dev/null
@@ -1,126 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools
-
-import firrtl.{ComposableOptions, ExecutionOptionsManager}
-import chisel3.iotesters.TesterOptionsManager
-
-case class DspTesterOptions(
-    // Top-level TB verbosity
-    isVerbose: Boolean = true,
-    // Expect Tolerance in LSBs for FixedPoint, SInt, UInt
-    fixTolLSBs: Int = 0,
-    // 10^(-realTolDecPts) tolerance for expect on DspReal
-    realTolDecPts: Int = 8,
-    // Generated mirroed Verilog TB from peek/poke
-    genVerilogTb: Boolean = false,
-    // clk period in ps = clkMul * tbTimeUnitPs
-    clkMul: Int = 1,
-    // Time unit in ps
-    tbTimeUnitPs: Int = 100,
-    // Time precision in ps
-    tbTimePrecisionPs: Int = 10,
-    // Input/output delay after which to peek/poke values (some fraction of clkMul)
-    inOutDelay: Double = 0.5,
-    // # clk periods for initial reset
-    initClkPeriods: Int = 5,
-    // # bit reduce to within this many sigma of mean, only applicable when using executeWithBitReduction
-    bitReduceBySigma: Double = 0.0,
-    // # max number of bit reduction passes
-    bitReduceMaxPasses: Int = 1,
-    // bitReduce, add this many bits to reduce amount,
-    bitReduceFudgeConstant: Int = 0
-) extends ComposableOptions {
-
-    val clkPeriodPs = tbTimeUnitPs * clkMul
-    val initTimeUnits = clkMul * initClkPeriods
-
-    require(tbTimeUnitPs >= tbTimePrecisionPs, "Time unit should be >= precision")
-    require(clkPeriodPs / 2 > tbTimePrecisionPs, "Half a clk period should be greater than time precision")
-    require(clkPeriodPs % 2 == 0, "Clk period should be divisible by 2")
-    require(initClkPeriods >= 1, "Reset should be applied for at least 1 clk period")
-
-}
-
-trait HasDspTesterOptions {
-
-  self: ExecutionOptionsManager =>
-
-  var dspTesterOptions = DspTesterOptions()
-
-  parser.note("dsp tester options")
-
-  parser.opt[Unit]("dsp-tester-is-verbose")
-    .abbr("dtiv")
-    .foreach { _ => dspTesterOptions = dspTesterOptions.copy(isVerbose = true) }
-    .text(s"set verbose flag on DspTesters, default is ${dspTesterOptions.isVerbose}")
-
-  parser.opt[Unit]("dsp-tester-is-not-verbose")
-    .abbr("dtinv")
-    .foreach { _ => dspTesterOptions = dspTesterOptions.copy(isVerbose = false) }
-    .text(s"unset verbose flag on DspTesters, default is ${dspTesterOptions.isVerbose}")
-
-  parser.opt[Unit]("gen-verilog-tb")
-    .abbr("gvtb")
-    .foreach { _ => dspTesterOptions = dspTesterOptions.copy(genVerilogTb = true) }
-    .text(s"set flag to generate tb .v file mimicking peek/poke, default is ${dspTesterOptions.genVerilogTb}")
-
-  parser.opt[Int]("fix-tol-lsb")
-    .abbr("ftlsb")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(fixTolLSBs = x) }
-    .text(s"fixed pt, sint, uint expect tolerance (# wrong LSBs OK), default is ${dspTesterOptions.fixTolLSBs}")
-
-  parser.opt[Int]("real-tol-dec-pts")
-    .abbr("rtdec")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(realTolDecPts = x) }
-    .text(s"real expect error tolerance (1e-n), default is ${dspTesterOptions.realTolDecPts}")
-
-  parser.opt[Int]("tb-time-unit-ps")
-    .abbr("tbunitps")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(tbTimeUnitPs = x) }
-    .text(s"tb time unit (# x) in ps, default is ${dspTesterOptions.tbTimeUnitPs}")
-
-  parser.opt[Int]("tb-time-prec-ps")
-    .abbr("tbprecps")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(tbTimePrecisionPs = x) }
-    .text(s"tb time precision in ps, default is ${dspTesterOptions.tbTimePrecisionPs}")
-
-  parser.opt[Int]("clk-mul")
-    .abbr("clkm")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(clkMul = x) }
-    .text(s"clk period = clk-mul * time unit (ps), default is ${dspTesterOptions.clkMul}")
-
-  parser.opt[Int]("init-clk-periods")
-    .abbr("initt")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(initClkPeriods = x) }
-    .text(s"initial reset time (# of clk periods), default is ${dspTesterOptions.initClkPeriods}")
-
-  parser.opt[Double]("bit-reduce-to-n-sigma")
-    .abbr("brtns")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(bitReduceBySigma = x) }
-    .text(
-      s"bit reduce to within mean + (this * sigma), default is ${dspTesterOptions.bitReduceBySigma} which => don't use"
-    )
-
-  parser.opt[Int]("bit-reduce-max-passes")
-    .abbr("brmp")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(bitReduceMaxPasses = x) }
-    .text(
-      s"bit reduce repeatedly until no changes or this many passes)," +
-        s"default is ${dspTesterOptions.bitReduceMaxPasses}"
-    )
-
-  parser.opt[Int]("bit-reduce-fudge-constant")
-    .abbr("brgb")
-    .foreach { x => dspTesterOptions = dspTesterOptions.copy(bitReduceFudgeConstant = x) }
-    .text(
-      s"bit-reduce guard bits, limit the reduction amount by adding this," +
-        s"default is ${dspTesterOptions.bitReduceMaxPasses}"
-    )
-
-}
-
-class DspTesterOptionsManager
-  extends TesterOptionsManager
-    with HasDspTesterOptions {
-}
diff --git a/src/main/scala/dsptools/tester/DspTesterUtilities.scala b/src/main/scala/dsptools/tester/DspTesterUtilities.scala
deleted file mode 100644
index 45bc4b86..00000000
--- a/src/main/scala/dsptools/tester/DspTesterUtilities.scala
+++ /dev/null
@@ -1,131 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools
-
-import chisel3._
-import chisel3.experimental.{FixedPoint, Interval}
-import dsptools.numbers.{DspComplex, DspReal}
-import chisel3.internal.InstanceId
-import chisel3.internal.firrtl.KnownBinaryPoint
-
-// TODO: Get rid of
-import chisel3.iotesters.TestersCompatibility
-
-//scalastyle:off cyclomatic.complexity method.length
-object DspTesterUtilities {
- 
-  // Converts signed Double's to their 2's complement BigInt equivalents (unsigned)
-  // (totalWidth, fractionalWidth of some FixedPoint)
-  def signedToBigIntUnsigned(x: Double, totalWidth: Int, fractionalWidth: Int): BigInt = {
-    val bi = FixedPoint.toBigInt(x, fractionalWidth)
-    val neg = bi < 0
-    val neededWidth = bi.bitLength + 1
-    require(neededWidth <= totalWidth, "Double -> BigInt width larger than total width allocated!")
-    if (neg) {
-      (BigInt(1) << totalWidth) + bi
-    } else {
-      bi
-    }
-  }
-
-  // Redundant from chisel-testers
-  // Converts unsigned BigInt to signed BigInt (width = width of Chisel data type)
-  def signConvert(bigInt: BigInt, width: Int): BigInt = {
-    require(bigInt >= 0, "signConvert assumes bigInt is >= 0!")
-    // Since the bigInt is always unsigned, bitLength always gets the max # of bits required to represent bigInt
-    val w = bigInt.bitLength.max(width)
-    // Negative if MSB is set or in this case, ex: 3 bit wide: negative if >= 4
-    if (bigInt >= (BigInt(1) << (w - 1))) (bigInt - (BigInt(1) << w)) else bigInt
-  }
-
-  // Converts a positive 2's complement BigInt to a Double - used for FixedPoint
-  def toDoubleFromUnsigned(i: BigInt, totalWidth: Int, fractionalWidth: Int): Double = {
-    val signedBigInt = signConvert(i, totalWidth)
-    FixedPoint.toDouble(signedBigInt, fractionalWidth)
-  }
-
-  // For DspReal represented as BigInt from Double (unsigned)
-  def doubleToBigIntBits(double: Double): BigInt = {
-    val ret = BigInt(java.lang.Double.doubleToLongBits(double))
-    if (ret >= 0) ret
-    else (BigInt(1) << DspReal.underlyingWidth) + ret
-  }
-
-  // For DspReal represented as BigInt back to Double
-  def bigIntBitsToDouble(bigInt: BigInt): Double = {
-    java.lang.Double.longBitsToDouble(bigInt.toLong)
-  }
-
-  // Used to get signal name for printing to console
-  private [dsptools] def getName(signal: InstanceId): String = {
-    s"${signal.parentPathName}.${TestersCompatibility.validName(signal.instanceName)}"
-  }
-
-  // Note: DspReal underlying is UInt
-  // Checks if a basic number is signed or unsigned
-  def isSigned(e: Data): Boolean = {
-    e match {
-      case _: SInt | _: FixedPoint | _: Interval => true
-      case _: DspReal | _: Bool | _: UInt => false
-      // Clock isn't a number, but it's still valid IO (should be treated as a Bool)
-      case _: Clock => false
-      case _ => throw DspException("Not a basic number/clock type! " + e)
-    }
-  }
-
-  // For printing to Verilog testbench (signed)
-  private [dsptools] def signPrefix(e: Element): String = {
-    def signed = isSigned(e)
-    if (signed) " signed "
-    else ""
-  }
-
-  // Determines if peek/poke data fits in bit width
-  def validRangeTest(signal: Data, value: BigInt) {
-    val len = value.bitLength
-    val neededLen = if (isSigned(signal)) len + 1 else len
-    require(signal.widthOption.nonEmpty, "Cannot check range of node with unknown width!")
-    if (neededLen > signal.getWidth) 
-      throw DspException(s"Value: $value is not in node ${getName(signal)} range")
-    if (!isSigned(signal) && value < 0)
-      throw DspException("Negative value can't be used with unsigned")
-  }
-
-  // Gets information on bitwidth, binarypoint for printing in console
-  def bitInfo(signal: Data): String = signal.widthOption match {
-    case Some(width) => {
-      signal match {
-        case i: Interval => i.binaryPoint match {
-          // Q integer . fractional bits
-          case KnownBinaryPoint(bp) => s"Q${width - 1 - bp}.$bp"
-          case _ => s"${width}-bit F"
-        }
-        case f: FixedPoint => f.binaryPoint match {
-          // Q integer . fractional bits
-          case KnownBinaryPoint(bp) => s"Q${width - 1 - bp}.$bp"
-          case _ => s"${width}-bit F"
-        }
-        case r: DspReal => "R"
-        case u: UInt => s"${width}-bit U"
-        case s: SInt => s"${width}-bit S"
-        case c: DspComplex[_] => {
-          val realInfo = bitInfo(c.real.asInstanceOf[Data])
-          val imagInfo = bitInfo(c.imag.asInstanceOf[Data])
-          s"[$realInfo, $imagInfo]"
-        }
-        case _ => throw DspException("Can't get bit info! Invalid type!")
-      }
-    }
-    case None => ""
-  }
-
-  // Round value if data type is integer
-  def roundData(data: Data, value: Double): Double = {
-    data match {
-      case _: SInt | _: UInt => value.round
-      case _: DspReal | _: FixedPoint | _: Interval => value
-      case _ => throw DspException("Invalid data type for rounding determination")
-    }
-  }
-
-}
diff --git a/src/main/scala/dsptools/tester/MemMasterModel.scala b/src/main/scala/dsptools/tester/MemMasterModel.scala
deleted file mode 100644
index e59cfc5b..00000000
--- a/src/main/scala/dsptools/tester/MemMasterModel.scala
+++ /dev/null
@@ -1,11 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools.tester
-
-trait MemMasterModel {
-  def memReadWord(addr: BigInt): BigInt
-  def memWriteWord(addr: BigInt, value: BigInt): Unit
-
-  def memReadWord(addr: Long): BigInt = memReadWord(BigInt(addr))
-  def memWriteWord(addr: Long, value: BigInt): Unit = memWriteWord(BigInt(addr), value)
-}
diff --git a/src/main/scala/dsptools/tester/VerilogTbDump.scala b/src/main/scala/dsptools/tester/VerilogTbDump.scala
deleted file mode 100644
index 8f901c86..00000000
--- a/src/main/scala/dsptools/tester/VerilogTbDump.scala
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-
-package dsptools
-
-import chisel3._
-import chisel3.experimental._
-import java.io.{BufferedWriter, File, FileWriter}
-
-import DspTesterUtilities._
-import chisel3.ActualDirection
-
-// TODO: Get rid of
-import chisel3.iotesters.TestersCompatibility
-
-// Note: This will dump as long as genVerilogTb is true (even if you're peeking/poking DspReal)
-trait VerilogTbDump {
-
-  def dut: MultiIOModule
-
-  // Used for getting target directory only (set in iotesters.Driver)
-  val iotestersOM = chisel3.iotesters.Driver.optionsManager
-  val targetDir = iotestersOM.targetDirName
-  val tbFileName = s"${targetDir}/tb.v"
-  val tb = new BufferedWriter(new FileWriter(tbFileName))
-
-  val dsptestersOpt = dsptools.Driver.optionsManager.dspTesterOptions
-  val verilogTb = dsptestersOpt.genVerilogTb
-
-  val (inputs, outputs) = TestersCompatibility.getModuleNames(dut).filter({
-    case (_, "clock") => false
-    case (_, "reset") => false
-    case _ => true
-  }).partition({
-    case (dat, _) =>
-      DataMirror.directionOf(dat) == ActualDirection.Input
-  })
-
-  if (verilogTb) initVerilogTbFile()
-  else deleteVerilogTbFile
-
-  def initVerilogTbFile() {
-    val dutName = dut.name
-
-    val resetTime = dsptestersOpt.initTimeUnits
-    // Input/output delay after which to peek/poke values
-    val clkDelta = dsptestersOpt.clkMul * dsptestersOpt.inOutDelay
-
-    tb write s"// SPDX-License-Identifier: Apache-2.0\n"
-    tb write s"// Example VCS Command: $$VCS_HOME/bin/vcs -debug_pp -full64 +define+UNIT_DELAY +rad +v2k +vcs+lic+wait " +
-    s"+vc+list +vcs+initreg+random +vcs+dumpvars+out.vcd tb.v ${dutName}.v ...\n"
-    
-    tb write s"`timescale ${dsptestersOpt.tbTimeUnitPs}ps / ${dsptestersOpt.tbTimePrecisionPs}ps\n"
-    tb write s"\n`define CLK_PERIOD ${dsptestersOpt.clkMul}\n"
-    tb write s"\n`define HALF_CLK_PERIOD ${dsptestersOpt.clkMul.toDouble/2}\n"
-    tb write s"`define RESET_TIME ${resetTime}\n"
-    tb write s"`define INIT_TIME ${clkDelta + resetTime}\n"
-
-    tb write "`define expect(nodeName, nodeVal, expVal, cycle) if (nodeVal !== expVal) begin " +
-      "\\\n  $display(\"\\t ASSERTION ON %s FAILED @ CYCLE = %d, 0x%h != EXPECTED 0x%h\", " +
-      "\\\n  nodeName,cycle,nodeVal,expVal); $stop; end\n\n"
-
-    tb write "module testbench_v;\n\n"
-
-    tb write "  integer cycle = 0;\n\n"
-
-    tb write "  reg clock = 1;\n"
-    tb write "  reg reset = 1;\n"
-      
-    inputs foreach { case (node, name) =>
-      val s = signPrefix(node)
-      tb write s"  reg$s[${node.getWidth-1}:0] $name = 0;\n"
-    }
-    outputs foreach { case (node, name) =>
-      val s = signPrefix(node)
-      tb write s"  wire$s[${node.getWidth-1}:0] ${name};\n"
-    }
-
-    tb write "\n  always #`HALF_CLK_PERIOD clock = ~clock;\n"
-
-    tb write "\n  initial begin\n"
-    tb write "    #`RESET_TIME\n"
-    tb write "    forever #`CLK_PERIOD cycle = cycle + 1;\n"
-    tb write "  end\n\n"
-
-    tb write s"  ${dutName} ${dutName}(\n"
-    tb write "    .clock(clock),\n"
-    tb write "    .reset(reset),\n"
-    tb write ((inputs ++ outputs).unzip._2 map (name => s"    .${name}(${name})") mkString ",\n")
-    tb write ");\n\n"
-
-    // Inputs fed delta after clk rising edge; read delta after clk rising edge
-    tb write "  initial begin\n"
-    tb write "    #`INIT_TIME reset = 0;\n"
-  }
-
-  def deleteVerilogTbFile() {
-    tb.close()
-    new File(tbFileName).delete()
-  }
-
-  def finishVerilogTb() {
-    if (verilogTb) {
-      tb write "\n    #`CLK_PERIOD $display(\"\\t **Ran through all test vectors**\"); $finish;\n"
-      tb write "\n  end\n"
-      tb write "endmodule"
-      tb.close()  
-    }
-  }
-
-  def stepPrint(n: Int) {
-    if (verilogTb) tb write s"    #($n*`CLK_PERIOD) "
-  }
-
-  def resetPrint(n: Int) {
-    if (verilogTb) tb write s"    reset = 1; #($n*`CLK_PERIOD) reset = 0;\n"
-  }
-
-  def pokePrint(signal: Element, value: BigInt) {
-    if (verilogTb) {
-      val matchingInput = inputs find (_._1 == signal)
-      matchingInput match {
-        case Some((_, name)) => {
-          // Don't have 0-width inputs (issue for >= #'s)
-          val bitLength = value.bitLength.max(1) 
-          val id = if (value >= 0) s"$bitLength\'d" else ""
-          tb write s"    $name = $id$value;\n"
-        }
-        case _ => // Don't print if not input
-      }
-    }
-  }
-
-  def peekPrint(signal: Element, res: BigInt) {
-    if (verilogTb) {
-      val matchingOutput = outputs find (_._1 == signal)
-      matchingOutput match {
-        case Some((_, name)) => {
-          //nodeName, nodeVal, expVal, cycle
-          tb write "    `expect(\"%s\",%s,%d,cycle)\n".format(name,name,res)
-        }
-        case _ => // Don't print if not output
-      }
-    }
-  }
-
-}
